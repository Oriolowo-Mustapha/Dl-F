import { PDPAuthHelper, PDPServer } from "../pdp/index.js";
import { asPieceCID } from "../piece/index.js";
import { SPRegistryService } from "../sp-registry/index.js";
import { calculateLastProofDate, createError, epochToDate, getCurrentEpoch, METADATA_KEYS, SIZE_CONSTANTS, TIMING_CONSTANTS, timeUntilEpoch, } from "../utils/index.js";
import { combineMetadata, metadataMatches, objectToEntries, validatePieceMetadata } from "../utils/metadata.js";
import { ProviderResolver } from "../utils/provider-resolver.js";
export class StorageContext {
    _synapse;
    _provider;
    _pdpServer;
    _warmStorageService;
    _warmStorageAddress;
    _withCDN;
    _dataSetId;
    _signer;
    _uploadBatchSize;
    _dataSetMetadata;
    _pendingPieces = [];
    _isProcessing = false;
    dataSetId;
    serviceProvider;
    get withCDN() {
        return this._withCDN;
    }
    get provider() {
        return this._provider;
    }
    get dataSetMetadata() {
        return this._dataSetMetadata;
    }
    static validateRawSize(sizeBytes, context) {
        if (sizeBytes < SIZE_CONSTANTS.MIN_UPLOAD_SIZE) {
            throw createError('StorageContext', context, `Data size ${sizeBytes} bytes is below minimum allowed size of ${SIZE_CONSTANTS.MIN_UPLOAD_SIZE} bytes`);
        }
        if (sizeBytes > SIZE_CONSTANTS.MAX_UPLOAD_SIZE) {
            throw createError('StorageContext', context, `Data size ${sizeBytes} bytes exceeds maximum allowed size of ${SIZE_CONSTANTS.MAX_UPLOAD_SIZE} bytes (${Math.floor(SIZE_CONSTANTS.MAX_UPLOAD_SIZE / 1024 / 1024)} MiB)`);
        }
    }
    constructor(synapse, warmStorageService, provider, dataSetId, options, dataSetMetadata) {
        this._synapse = synapse;
        this._provider = provider;
        this._dataSetId = dataSetId;
        this._withCDN = options.withCDN ?? false;
        this._signer = synapse.getSigner();
        this._warmStorageService = warmStorageService;
        this._uploadBatchSize = Math.max(1, options.uploadBatchSize ?? SIZE_CONSTANTS.DEFAULT_UPLOAD_BATCH_SIZE);
        this._dataSetMetadata = dataSetMetadata;
        this.dataSetId = dataSetId;
        this.serviceProvider = provider.serviceProvider;
        this._warmStorageAddress = synapse.getWarmStorageAddress();
        const authHelper = new PDPAuthHelper(this._warmStorageAddress, this._signer, BigInt(synapse.getChainId()));
        if (!provider.products.PDP?.data.serviceURL) {
            throw new Error(`Provider ${provider.id} does not have a PDP product with serviceURL`);
        }
        this._pdpServer = new PDPServer(authHelper, provider.products.PDP.data.serviceURL);
    }
    static async create(synapse, warmStorageService, options = {}) {
        const registryAddress = warmStorageService.getServiceProviderRegistryAddress();
        const spRegistry = new SPRegistryService(synapse.getProvider(), registryAddress);
        const providerResolver = new ProviderResolver(warmStorageService, spRegistry);
        const resolution = await StorageContext.resolveProviderAndDataSet(synapse, warmStorageService, providerResolver, options);
        try {
            options.callbacks?.onProviderSelected?.(resolution.provider);
        }
        catch (error) {
            console.error('Error in onProviderSelected callback:', error);
        }
        let finalDataSetId;
        if (resolution.dataSetId === -1 || options.forceCreateDataSet === true) {
            finalDataSetId = await StorageContext.createDataSet(synapse, warmStorageService, resolution.provider, options.withCDN ?? false, options.callbacks, options.metadata);
        }
        else {
            finalDataSetId = resolution.dataSetId;
            try {
                options.callbacks?.onDataSetResolved?.({
                    isExisting: resolution.isExisting ?? true,
                    dataSetId: finalDataSetId,
                    provider: resolution.provider,
                });
            }
            catch (error) {
                console.error('Error in onDataSetResolved callback:', error);
            }
        }
        return new StorageContext(synapse, warmStorageService, resolution.provider, finalDataSetId, options, resolution.dataSetMetadata);
    }
    static async createDataSet(synapse, warmStorageService, provider, withCDN, callbacks, metadata) {
        performance.mark('synapse:createDataSet-start');
        const signer = synapse.getSigner();
        const signerAddress = await signer.getAddress();
        const nextDatasetId = await warmStorageService.getNextClientDataSetId(signerAddress);
        const warmStorageAddress = synapse.getWarmStorageAddress();
        const authHelper = new PDPAuthHelper(warmStorageAddress, signer, BigInt(synapse.getChainId()));
        if (!provider.products.PDP?.data.serviceURL) {
            throw new Error(`Provider ${provider.id} does not have a PDP product with serviceURL`);
        }
        const pdpServer = new PDPServer(authHelper, provider.products.PDP.data.serviceURL);
        const baseMetadataObj = metadata ?? {};
        const metadataObj = withCDN && !(METADATA_KEYS.WITH_CDN in baseMetadataObj)
            ? { ...baseMetadataObj, [METADATA_KEYS.WITH_CDN]: '' }
            : baseMetadataObj;
        const finalMetadata = objectToEntries(metadataObj);
        performance.mark('synapse:pdpServer.createDataSet-start');
        const createResult = await pdpServer.createDataSet(nextDatasetId, provider.payee, finalMetadata, warmStorageAddress);
        performance.mark('synapse:pdpServer.createDataSet-end');
        performance.measure('synapse:pdpServer.createDataSet', 'synapse:pdpServer.createDataSet-start', 'synapse:pdpServer.createDataSet-end');
        const { txHash, statusUrl } = createResult;
        const ethersProvider = synapse.getProvider();
        let transaction = null;
        const txRetryStartTime = Date.now();
        const txPropagationTimeout = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_TIMEOUT_MS;
        const txPropagationPollInterval = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;
        performance.mark('synapse:getTransaction-start');
        while (Date.now() - txRetryStartTime < txPropagationTimeout) {
            try {
                transaction = await ethersProvider.getTransaction(txHash);
                if (transaction !== null) {
                    break;
                }
            }
            catch (error) {
                console.warn(`Failed to fetch transaction ${txHash}, retrying...`, error);
            }
            await new Promise((resolve) => setTimeout(resolve, txPropagationPollInterval));
        }
        performance.mark('synapse:getTransaction-end');
        performance.measure('synapse:getTransaction', 'synapse:getTransaction-start', 'synapse:getTransaction-end');
        if (transaction === null) {
            throw createError('StorageContext', 'create', `Transaction ${txHash} not found after ${txPropagationTimeout / 1000} seconds. The transaction may not have propagated to the RPC node.`);
        }
        try {
            callbacks?.onDataSetCreationStarted?.(transaction, statusUrl);
        }
        catch (error) {
            console.error('Error in onDataSetCreationStarted callback:', error);
        }
        let finalStatus;
        performance.mark('synapse:waitForDataSetCreationWithStatus-start');
        try {
            finalStatus = await warmStorageService.waitForDataSetCreationWithStatus(transaction, pdpServer, TIMING_CONSTANTS.DATA_SET_CREATION_TIMEOUT_MS, TIMING_CONSTANTS.DATA_SET_CREATION_POLL_INTERVAL_MS, async (status, elapsedMs) => {
                if (callbacks?.onDataSetCreationProgress != null) {
                    try {
                        let receipt;
                        if (status.chainStatus.transactionMined && status.chainStatus.blockNumber != null) {
                            try {
                                const txReceipt = await transaction.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
                                receipt = txReceipt ?? undefined;
                            }
                            catch (error) {
                                console.error('Failed to fetch transaction receipt:', error);
                            }
                        }
                        callbacks.onDataSetCreationProgress({
                            transactionMined: status.chainStatus.transactionMined,
                            transactionSuccess: status.chainStatus.transactionSuccess,
                            dataSetLive: status.chainStatus.dataSetLive,
                            serverConfirmed: status.serverStatus?.ok === true,
                            dataSetId: status.summary.dataSetId ?? undefined,
                            elapsedMs,
                            receipt,
                        });
                    }
                    catch (error) {
                        console.error('Error in onDataSetCreationProgress callback:', error);
                    }
                }
            });
        }
        catch (error) {
            performance.mark('synapse:waitForDataSetCreationWithStatus-end');
            performance.measure('synapse:waitForDataSetCreationWithStatus', 'synapse:waitForDataSetCreationWithStatus-start', 'synapse:waitForDataSetCreationWithStatus-end');
            throw createError('StorageContext', 'waitForDataSetCreation', error instanceof Error ? error.message : 'Data set creation failed');
        }
        performance.mark('synapse:waitForDataSetCreationWithStatus-end');
        performance.measure('synapse:waitForDataSetCreationWithStatus', 'synapse:waitForDataSetCreationWithStatus-start', 'synapse:waitForDataSetCreationWithStatus-end');
        if (!finalStatus.summary.isComplete || finalStatus.summary.dataSetId == null) {
            throw createError('StorageContext', 'waitForDataSetCreation', `Data set creation failed: ${finalStatus.summary.error ?? 'Transaction may have failed'}`);
        }
        const dataSetId = finalStatus.summary.dataSetId;
        try {
            callbacks?.onDataSetResolved?.({
                isExisting: false,
                dataSetId,
                provider,
            });
        }
        catch (error) {
            console.error('Error in onDataSetResolved callback:', error);
        }
        performance.mark('synapse:createDataSet-end');
        performance.measure('synapse:createDataSet', 'synapse:createDataSet-start', 'synapse:createDataSet-end');
        return dataSetId;
    }
    static async resolveProviderAndDataSet(synapse, warmStorageService, providerResolver, options) {
        const signer = synapse.getSigner();
        const signerAddress = await signer.getAddress();
        if (options.dataSetId != null) {
            return await StorageContext.resolveByDataSetId(options.dataSetId, warmStorageService, providerResolver, signerAddress, options);
        }
        const requestedMetadata = combineMetadata(options.metadata, options.withCDN);
        if (options.providerId != null) {
            return await StorageContext.resolveByProviderId(signerAddress, options.providerId, requestedMetadata, warmStorageService, providerResolver);
        }
        if (options.providerAddress != null) {
            return await StorageContext.resolveByProviderAddress(options.providerAddress, warmStorageService, providerResolver, signerAddress, requestedMetadata);
        }
        return await StorageContext.smartSelectProvider(signerAddress, requestedMetadata, warmStorageService, providerResolver, signer);
    }
    static async resolveByDataSetId(dataSetId, warmStorageService, providerResolver, signerAddress, options) {
        const dataSets = await warmStorageService.getClientDataSetsWithDetails(signerAddress);
        const dataSet = dataSets.find((ds) => ds.pdpVerifierDataSetId === dataSetId);
        if (dataSet == null || !dataSet.isLive || !dataSet.isManaged) {
            throw createError('StorageContext', 'resolveByDataSetId', `Data set ${dataSetId} not found, not owned by ${signerAddress}, ` +
                'or not managed by the current WarmStorage contract');
        }
        if (options.providerId != null || options.providerAddress != null) {
            await StorageContext.validateDataSetConsistency(dataSet, options, providerResolver);
        }
        const provider = await providerResolver.getApprovedProvider(dataSet.providerId);
        if (provider == null) {
            throw createError('StorageContext', 'resolveByDataSetId', `Provider ID ${dataSet.providerId} for data set ${dataSetId} is not currently approved`);
        }
        if (options.withCDN != null && dataSet.withCDN !== options.withCDN) {
            throw createError('StorageContext', 'resolveByDataSetId', `Data set ${dataSetId} has CDN ${dataSet.withCDN ? 'enabled' : 'disabled'}, ` +
                `but requested ${options.withCDN ? 'enabled' : 'disabled'}`);
        }
        const dataSetMetadata = await warmStorageService.getDataSetMetadata(dataSetId);
        return {
            provider,
            dataSetId,
            isExisting: true,
            dataSetMetadata,
        };
    }
    static async validateDataSetConsistency(dataSet, options, providerResolver) {
        if (options.providerId != null) {
            if (dataSet.providerId !== options.providerId) {
                throw createError('StorageContext', 'validateDataSetConsistency', `Data set ${dataSet.pdpVerifierDataSetId} belongs to provider ID ${dataSet.providerId}, ` +
                    `but provider ID ${options.providerId} was requested`);
            }
        }
        if (options.providerAddress != null) {
            const actualProvider = await providerResolver.getApprovedProvider(dataSet.providerId);
            if (actualProvider == null ||
                actualProvider.serviceProvider.toLowerCase() !== options.providerAddress.toLowerCase()) {
                throw createError('StorageContext', 'validateDataSetConsistency', `Data set ${dataSet.pdpVerifierDataSetId} belongs to provider ${actualProvider?.serviceProvider ?? 'unknown'}, ` +
                    `but provider ${options.providerAddress} was requested`);
            }
        }
    }
    static async resolveByProviderId(signerAddress, providerId, requestedMetadata, warmStorageService, providerResolver) {
        const [provider, dataSets] = await Promise.all([
            providerResolver.getApprovedProvider(providerId),
            warmStorageService.getClientDataSetsWithDetails(signerAddress),
        ]);
        if (provider == null) {
            throw createError('StorageContext', 'resolveByProviderId', `Provider ID ${providerId} is not currently approved`);
        }
        const providerDataSets = dataSets.filter((ps) => {
            if (ps.providerId !== provider.id || !ps.isLive || !ps.isManaged) {
                return false;
            }
            return metadataMatches(ps.metadata, requestedMetadata);
        });
        if (providerDataSets.length > 0) {
            const sorted = providerDataSets.sort((a, b) => {
                if (a.currentPieceCount > 0 && b.currentPieceCount === 0)
                    return -1;
                if (b.currentPieceCount > 0 && a.currentPieceCount === 0)
                    return 1;
                return a.pdpVerifierDataSetId - b.pdpVerifierDataSetId;
            });
            const dataSetMetadata = await warmStorageService.getDataSetMetadata(sorted[0].pdpVerifierDataSetId);
            return {
                provider,
                dataSetId: sorted[0].pdpVerifierDataSetId,
                isExisting: true,
                dataSetMetadata,
            };
        }
        return {
            provider,
            dataSetId: -1,
            isExisting: false,
            dataSetMetadata: requestedMetadata,
        };
    }
    static async resolveByProviderAddress(providerAddress, warmStorageService, providerResolver, signerAddress, requestedMetadata) {
        const provider = await providerResolver.getApprovedProviderByAddress(providerAddress);
        if (provider == null) {
            throw createError('StorageContext', 'resolveByProviderAddress', `Provider ${providerAddress} is not currently approved`);
        }
        return await StorageContext.resolveByProviderId(signerAddress, provider.id, requestedMetadata, warmStorageService, providerResolver);
    }
    static async smartSelectProvider(signerAddress, requestedMetadata, warmStorageService, providerResolver, signer) {
        const dataSets = await warmStorageService.getClientDataSetsWithDetails(signerAddress);
        const managedDataSets = dataSets.filter((ps) => ps.isLive && ps.isManaged && metadataMatches(ps.metadata, requestedMetadata));
        if (managedDataSets.length > 0) {
            const sorted = managedDataSets.sort((a, b) => {
                if (a.currentPieceCount > 0 && b.currentPieceCount === 0)
                    return -1;
                if (b.currentPieceCount > 0 && a.currentPieceCount === 0)
                    return 1;
                return a.pdpVerifierDataSetId - b.pdpVerifierDataSetId;
            });
            async function* generateProviders() {
                const yieldedProviders = new Set();
                for (const dataSet of sorted) {
                    const provider = await providerResolver.getApprovedProvider(dataSet.providerId);
                    if (provider == null) {
                        console.warn(`Provider ID ${dataSet.providerId} for data set ${dataSet.pdpVerifierDataSetId} is not currently approved`);
                        continue;
                    }
                    if (!yieldedProviders.has(provider.serviceProvider.toLowerCase())) {
                        yieldedProviders.add(provider.serviceProvider.toLowerCase());
                        yield provider;
                    }
                }
            }
            try {
                const selectedProvider = await StorageContext.selectProviderWithPing(generateProviders());
                const matchingDataSet = sorted.find((ps) => ps.providerId === selectedProvider.id);
                if (matchingDataSet == null) {
                    console.warn(`Could not match selected provider ${selectedProvider.serviceProvider} (ID: ${selectedProvider.id}) ` +
                        `to existing data sets. Falling back to selecting from all providers.`);
                }
                else {
                    const dataSetMetadata = await warmStorageService.getDataSetMetadata(matchingDataSet.pdpVerifierDataSetId);
                    return {
                        provider: selectedProvider,
                        dataSetId: matchingDataSet.pdpVerifierDataSetId,
                        isExisting: true,
                        dataSetMetadata,
                    };
                }
            }
            catch (_error) {
                console.warn('All providers from existing data sets failed health check. Falling back to all providers.');
            }
        }
        const allProviders = await providerResolver.getApprovedProviders();
        if (allProviders.length === 0) {
            throw createError('StorageContext', 'smartSelectProvider', 'No approved service providers available');
        }
        const provider = await StorageContext.selectRandomProvider(allProviders, signer);
        return {
            provider,
            dataSetId: -1,
            isExisting: false,
            dataSetMetadata: requestedMetadata,
        };
    }
    static async selectRandomProvider(providers, signer) {
        if (providers.length === 0) {
            throw createError('StorageContext', 'selectRandomProvider', 'No providers available');
        }
        async function* generateRandomProviders() {
            const remaining = [...providers];
            while (remaining.length > 0) {
                let randomIndex;
                if (typeof globalThis.crypto !== 'undefined' && globalThis.crypto.getRandomValues != null) {
                    const randomBytes = new Uint8Array(1);
                    globalThis.crypto.getRandomValues(randomBytes);
                    randomIndex = randomBytes[0] % remaining.length;
                }
                else {
                    const timestamp = Date.now();
                    const random = Math.random();
                    if (signer != null) {
                        const addressBytes = await signer.getAddress();
                        const addressSum = addressBytes.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
                        const combined = (timestamp * random * addressSum) % remaining.length;
                        randomIndex = Math.floor(Math.abs(combined));
                    }
                    else {
                        randomIndex = Math.floor(Math.random() * remaining.length);
                    }
                }
                const selected = remaining.splice(randomIndex, 1)[0];
                yield selected;
            }
        }
        return await StorageContext.selectProviderWithPing(generateRandomProviders());
    }
    static async selectProviderWithPing(providers) {
        let providerCount = 0;
        for await (const provider of providers) {
            providerCount++;
            try {
                if (!provider.products.PDP?.data.serviceURL) {
                    continue;
                }
                const providerPdpServer = new PDPServer(null, provider.products.PDP.data.serviceURL);
                await providerPdpServer.ping();
                return provider;
            }
            catch (error) {
                console.warn(`Provider ${provider.serviceProvider} failed ping test:`, error instanceof Error ? error.message : String(error));
            }
        }
        if (providerCount === 0) {
            throw createError('StorageContext', 'selectProviderWithPing', 'No providers available to select from');
        }
        throw createError('StorageContext', 'selectProviderWithPing', `All ${providerCount} providers failed health check. Storage may be temporarily unavailable.`);
    }
    static async performPreflightCheck(warmStorageService, paymentsService, size, withCDN) {
        StorageContext.validateRawSize(size, 'preflightUpload');
        const allowanceCheck = await warmStorageService.checkAllowanceForStorage(size, withCDN, paymentsService);
        return {
            estimatedCost: {
                perEpoch: allowanceCheck.costs.perEpoch,
                perDay: allowanceCheck.costs.perDay,
                perMonth: allowanceCheck.costs.perMonth,
            },
            allowanceCheck: {
                sufficient: allowanceCheck.sufficient,
                message: allowanceCheck.message,
            },
            selectedProvider: null,
            selectedDataSetId: null,
        };
    }
    async preflightUpload(size) {
        const preflightResult = await StorageContext.performPreflightCheck(this._warmStorageService, this._synapse.payments, size, this._withCDN);
        return {
            ...preflightResult,
            selectedProvider: this._provider,
            selectedDataSetId: this._dataSetId,
        };
    }
    async upload(data, options) {
        performance.mark('synapse:upload-start');
        const dataBytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
        const sizeBytes = dataBytes.length;
        StorageContext.validateRawSize(sizeBytes, 'upload');
        let uploadResult;
        try {
            performance.mark('synapse:pdpServer.uploadPiece-start');
            uploadResult = await this._pdpServer.uploadPiece(dataBytes);
            performance.mark('synapse:pdpServer.uploadPiece-end');
            performance.measure('synapse:pdpServer.uploadPiece', 'synapse:pdpServer.uploadPiece-start', 'synapse:pdpServer.uploadPiece-end');
        }
        catch (error) {
            performance.mark('synapse:pdpServer.uploadPiece-end');
            performance.measure('synapse:pdpServer.uploadPiece', 'synapse:pdpServer.uploadPiece-start', 'synapse:pdpServer.uploadPiece-end');
            throw createError('StorageContext', 'uploadPiece', 'Failed to upload piece to service provider', error);
        }
        const maxWaitTime = TIMING_CONSTANTS.PIECE_PARKING_TIMEOUT_MS;
        const pollInterval = TIMING_CONSTANTS.PIECE_PARKING_POLL_INTERVAL_MS;
        const startTime = Date.now();
        let pieceReady = false;
        performance.mark('synapse:findPiece-start');
        while (Date.now() - startTime < maxWaitTime) {
            try {
                await this._pdpServer.findPiece(uploadResult.pieceCid);
                pieceReady = true;
                break;
            }
            catch {
                if (Date.now() - startTime + pollInterval < maxWaitTime) {
                    await new Promise((resolve) => setTimeout(resolve, pollInterval));
                }
            }
        }
        performance.mark('synapse:findPiece-end');
        performance.measure('synapse:findPiece', 'synapse:findPiece-start', 'synapse:findPiece-end');
        if (!pieceReady) {
            throw createError('StorageContext', 'findPiece', 'Timeout waiting for piece to be parked on service provider');
        }
        if (options?.onUploadComplete != null) {
            options.onUploadComplete(uploadResult.pieceCid);
        }
        const pieceData = uploadResult.pieceCid;
        if (options?.metadata != null) {
            validatePieceMetadata(options.metadata);
        }
        const finalPieceId = await new Promise((resolve, reject) => {
            this._pendingPieces.push({
                pieceData,
                resolve,
                reject,
                callbacks: options,
                metadata: options?.metadata ? objectToEntries(options.metadata) : undefined,
            });
            setTimeout(() => {
                void this._processPendingPieces().catch((error) => {
                    console.error('Failed to process pending pieces batch:', error);
                });
            }, 0);
        });
        performance.mark('synapse:upload-end');
        performance.measure('synapse:upload', 'synapse:upload-start', 'synapse:upload-end');
        return {
            pieceCid: uploadResult.pieceCid,
            size: uploadResult.size,
            pieceId: finalPieceId,
        };
    }
    async _processPendingPieces() {
        if (this._isProcessing || this._pendingPieces.length === 0) {
            return;
        }
        this._isProcessing = true;
        const batch = this._pendingPieces.slice(0, this._uploadBatchSize);
        this._pendingPieces = this._pendingPieces.slice(this._uploadBatchSize);
        try {
            performance.mark('synapse:getAddPiecesInfo-start');
            const addPiecesInfo = await this._warmStorageService.getAddPiecesInfo(this._dataSetId);
            performance.mark('synapse:getAddPiecesInfo-end');
            performance.measure('synapse:getAddPiecesInfo', 'synapse:getAddPiecesInfo-start', 'synapse:getAddPiecesInfo-end');
            const pieceDataArray = batch.map((item) => item.pieceData);
            const metadataArray = batch.map((item) => item.metadata ?? []);
            performance.mark('synapse:pdpServer.addPieces-start');
            const addPiecesResult = await this._pdpServer.addPieces(this._dataSetId, addPiecesInfo.clientDataSetId, addPiecesInfo.nextPieceId, pieceDataArray, metadataArray);
            performance.mark('synapse:pdpServer.addPieces-end');
            performance.measure('synapse:pdpServer.addPieces', 'synapse:pdpServer.addPieces-start', 'synapse:pdpServer.addPieces-end');
            let confirmedPieceIds = [];
            if (addPiecesResult.txHash == null) {
                throw createError('StorageContext', 'addPieces', 'Server did not return a transaction hash for piece addition');
            }
            let transaction = null;
            const txRetryStartTime = Date.now();
            const txPropagationTimeout = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_TIMEOUT_MS;
            const txPropagationPollInterval = TIMING_CONSTANTS.TRANSACTION_PROPAGATION_POLL_INTERVAL_MS;
            performance.mark('synapse:getTransaction.addPieces-start');
            while (Date.now() - txRetryStartTime < txPropagationTimeout) {
                try {
                    transaction = await this._synapse.getProvider().getTransaction(addPiecesResult.txHash);
                    if (transaction !== null)
                        break;
                }
                catch {
                }
                await new Promise((resolve) => setTimeout(resolve, txPropagationPollInterval));
            }
            performance.mark('synapse:getTransaction.addPieces-end');
            performance.measure('synapse:getTransaction.addPieces', 'synapse:getTransaction.addPieces-start', 'synapse:getTransaction.addPieces-end');
            if (transaction == null) {
                throw createError('StorageContext', 'addPieces', `Server returned transaction hash ${addPiecesResult.txHash} but transaction was not found on-chain after ${txPropagationTimeout / 1000} seconds`);
            }
            batch.forEach((item) => {
                item.callbacks?.onPieceAdded?.(transaction);
            });
            let receipt;
            try {
                performance.mark('synapse:transaction.wait-start');
                receipt = await transaction.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS);
                performance.mark('synapse:transaction.wait-end');
                performance.measure('synapse:transaction.wait', 'synapse:transaction.wait-start', 'synapse:transaction.wait-end');
            }
            catch (error) {
                performance.mark('synapse:transaction.wait-end');
                performance.measure('synapse:transaction.wait', 'synapse:transaction.wait-start', 'synapse:transaction.wait-end');
                throw createError('StorageContext', 'addPieces', 'Failed to wait for transaction confirmation', error);
            }
            if (receipt?.status !== 1) {
                throw createError('StorageContext', 'addPieces', 'Piece addition transaction  failed on-chain');
            }
            const maxWaitTime = TIMING_CONSTANTS.PIECE_ADDITION_TIMEOUT_MS;
            const pollInterval = TIMING_CONSTANTS.PIECE_ADDITION_POLL_INTERVAL_MS;
            const startTime = Date.now();
            let lastError = null;
            let statusVerified = false;
            performance.mark('synapse:getPieceAdditionStatus-start');
            while (Date.now() - startTime < maxWaitTime) {
                try {
                    const status = await this._pdpServer.getPieceAdditionStatus(this._dataSetId, addPiecesResult.txHash);
                    if (status.txStatus === 'pending' || status.addMessageOk === null) {
                        await new Promise((resolve) => setTimeout(resolve, pollInterval));
                        continue;
                    }
                    if (!status.addMessageOk) {
                        throw new Error('Piece addition failed: Transaction was unsuccessful');
                    }
                    if (status.confirmedPieceIds != null && status.confirmedPieceIds.length > 0) {
                        confirmedPieceIds = status.confirmedPieceIds;
                        batch.forEach((item) => {
                            item.callbacks?.onPieceConfirmed?.(status.confirmedPieceIds ?? []);
                        });
                        statusVerified = true;
                        break;
                    }
                    await new Promise((resolve) => setTimeout(resolve, pollInterval));
                }
                catch (error) {
                    lastError = error;
                    if (error instanceof Error && error.message.includes('not found')) {
                        await new Promise((resolve) => setTimeout(resolve, pollInterval));
                        continue;
                    }
                    throw createError('StorageContext', 'addPieces', `Failed to verify piece addition with server: ${error instanceof Error ? error.message : 'Unknown error'}`, error);
                }
            }
            performance.mark('synapse:getPieceAdditionStatus-end');
            performance.measure('synapse:getPieceAdditionStatus', 'synapse:getPieceAdditionStatus-start', 'synapse:getPieceAdditionStatus-end');
            if (!statusVerified) {
                const errorMessage = `Failed to verify piece addition after ${maxWaitTime / 1000} seconds: ${lastError != null ? lastError.message : 'Server did not provide confirmation'}`;
                throw createError('StorageContext', 'addPieces', `${errorMessage}. The transaction was confirmed on-chain but the server failed to acknowledge it.`, lastError);
            }
            batch.forEach((item, index) => {
                const pieceId = confirmedPieceIds[index] ?? addPiecesInfo.nextPieceId + index;
                item.resolve(pieceId);
            });
        }
        catch (error) {
            const finalError = createError('StorageContext', 'addPieces', 'Failed to add piece to data set', error);
            batch.forEach((item) => {
                item.reject(finalError);
            });
        }
        finally {
            this._isProcessing = false;
            if (this._pendingPieces.length > 0) {
                void this._processPendingPieces().catch((error) => {
                    console.error('Failed to process pending pieces batch:', error);
                });
            }
        }
    }
    async download(pieceCid, options) {
        const downloadFn = this._synapse.storage?.download ?? this._synapse.download;
        return await downloadFn.call(this._synapse.storage ?? this._synapse, pieceCid, {
            providerAddress: this._provider.serviceProvider,
            withCDN: options?.withCDN ?? this._withCDN,
        });
    }
    async providerDownload(pieceCid, options) {
        console.warn('providerDownload() is deprecated. Use download() instead.');
        return await this.download(pieceCid, options);
    }
    async getProviderInfo() {
        return await this._synapse.getProviderInfo(this.serviceProvider);
    }
    async getDataSetPieces() {
        const dataSetData = await this._pdpServer.getDataSet(this._dataSetId);
        return dataSetData.pieces.map((piece) => piece.pieceCid);
    }
    async hasPiece(pieceCid) {
        const parsedPieceCID = asPieceCID(pieceCid);
        if (parsedPieceCID == null) {
            return false;
        }
        try {
            await this._pdpServer.findPiece(parsedPieceCID);
            return true;
        }
        catch {
            return false;
        }
    }
    async pieceStatus(pieceCid) {
        const parsedPieceCID = asPieceCID(pieceCid);
        if (parsedPieceCID == null) {
            throw createError('StorageContext', 'pieceStatus', 'Invalid PieceCID provided');
        }
        const [exists, dataSetData, currentEpoch] = await Promise.all([
            this.hasPiece(parsedPieceCID),
            this._pdpServer
                .getDataSet(this._dataSetId)
                .catch((error) => {
                console.debug('Failed to get data set data:', error);
                return null;
            }),
            getCurrentEpoch(this._synapse.getProvider()),
        ]);
        const network = this._synapse.getNetwork();
        let retrievalUrl = null;
        let pieceId;
        let lastProven = null;
        let nextProofDue = null;
        let inChallengeWindow = false;
        let hoursUntilChallengeWindow = 0;
        let isProofOverdue = false;
        if (exists) {
            const [providerInfo, provingParams] = await Promise.all([
                this.getProviderInfo().catch(() => null),
                dataSetData != null
                    ? Promise.all([this._warmStorageService.getMaxProvingPeriod(), this._warmStorageService.getChallengeWindow()])
                        .then(([maxProvingPeriod, challengeWindow]) => ({
                        maxProvingPeriod,
                        challengeWindow,
                    }))
                        .catch(() => null)
                    : Promise.resolve(null),
            ]);
            if (providerInfo != null) {
                if (!providerInfo.products.PDP?.data.serviceURL) {
                    throw new Error(`Provider ${providerInfo.id} does not have a PDP product with serviceURL`);
                }
                retrievalUrl = `${providerInfo.products.PDP.data.serviceURL.replace(/\/$/, '')}/piece/${parsedPieceCID.toString()}`;
            }
            if (dataSetData != null && provingParams != null) {
                const pieceData = dataSetData.pieces.find((piece) => piece.pieceCid.toString() === parsedPieceCID.toString());
                if (pieceData != null) {
                    pieceId = pieceData.pieceId;
                    if (dataSetData.nextChallengeEpoch > 0) {
                        const challengeWindowStart = dataSetData.nextChallengeEpoch;
                        const provingDeadline = challengeWindowStart + provingParams.challengeWindow;
                        nextProofDue = epochToDate(provingDeadline, network);
                        const lastProvenDate = calculateLastProofDate(dataSetData.nextChallengeEpoch, provingParams.maxProvingPeriod, network);
                        if (lastProvenDate != null) {
                            lastProven = lastProvenDate;
                        }
                        inChallengeWindow = Number(currentEpoch) >= challengeWindowStart && Number(currentEpoch) < provingDeadline;
                        isProofOverdue = Number(currentEpoch) >= provingDeadline;
                        if (Number(currentEpoch) < challengeWindowStart) {
                            const timeUntil = timeUntilEpoch(challengeWindowStart, Number(currentEpoch));
                            hoursUntilChallengeWindow = timeUntil.hours;
                        }
                    }
                    else {
                        console.debug('Data set has nextChallengeEpoch=0, may have just been proven');
                    }
                }
            }
        }
        return {
            exists,
            dataSetLastProven: lastProven,
            dataSetNextProofDue: nextProofDue,
            retrievalUrl,
            pieceId,
            inChallengeWindow,
            hoursUntilChallengeWindow,
            isProofOverdue,
        };
    }
    async terminate() {
        return this._synapse.storage.terminateDataSet(this._dataSetId);
    }
}
//# sourceMappingURL=context.js.map