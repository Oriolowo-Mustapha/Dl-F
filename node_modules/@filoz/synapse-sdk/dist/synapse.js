import { ethers } from 'ethers';
import { PaymentsService } from "./payments/index.js";
import { ChainRetriever, FilCdnRetriever, SubgraphRetriever } from "./retriever/index.js";
import { SPRegistryService } from "./sp-registry/index.js";
import { StorageManager } from "./storage/manager.js";
import { SubgraphService } from "./subgraph/service.js";
import { CHAIN_IDS, CONTRACT_ADDRESSES, getFilecoinNetworkType } from "./utils/index.js";
import { ProviderResolver } from "./utils/provider-resolver.js";
import { WarmStorageService } from "./warm-storage/index.js";
export class Synapse {
    _signer;
    _network;
    _withCDN;
    _payments;
    _provider;
    _warmStorageAddress;
    _warmStorageService;
    _pieceRetriever;
    _storageManager;
    static async create(options) {
        const providedOptions = [options.privateKey, options.provider, options.signer].filter(Boolean).length;
        if (providedOptions !== 1) {
            throw new Error('Must provide exactly one of: privateKey, provider, or signer');
        }
        let network;
        let signer;
        let provider;
        if (options.privateKey != null) {
            const rpcURL = options.rpcURL ?? options.rpcURL;
            if (rpcURL == null) {
                throw new Error('rpcURL is required when using privateKey');
            }
            let privateKey = options.privateKey;
            if (!privateKey.startsWith('0x')) {
                privateKey = `0x${privateKey}`;
            }
            if (/^ws(s)?:\/\//i.test(rpcURL)) {
                provider = new ethers.WebSocketProvider(rpcURL);
            }
            else {
                provider = new ethers.JsonRpcProvider(rpcURL);
            }
            network = await getFilecoinNetworkType(provider);
            const wallet = new ethers.Wallet(privateKey, provider);
            signer = options.disableNonceManager === true ? wallet : new ethers.NonceManager(wallet);
        }
        else if (options.provider != null) {
            provider = options.provider;
            network = await getFilecoinNetworkType(provider);
            if ('getSigner' in provider && typeof provider.getSigner === 'function') {
                const baseSigner = await provider.getSigner(0);
                signer = options.disableNonceManager === true ? baseSigner : new ethers.NonceManager(baseSigner);
            }
            else {
                throw new Error('Provider does not support signing operations');
            }
        }
        else if (options.signer != null) {
            signer = options.signer;
            if (options.disableNonceManager !== true && !(signer instanceof ethers.NonceManager)) {
                signer = new ethers.NonceManager(signer);
            }
            if (signer.provider == null) {
                throw new Error('Signer must have a provider');
            }
            provider = signer.provider;
            network = await getFilecoinNetworkType(provider);
        }
        else {
            throw new Error('No valid authentication method provided');
        }
        if (network !== 'mainnet' && network !== 'calibration') {
            throw new Error(`Invalid network: ${String(network)}. Only 'mainnet' and 'calibration' are supported.`);
        }
        const warmStorageAddress = options.warmStorageAddress ?? CONTRACT_ADDRESSES.WARM_STORAGE[network];
        if (!warmStorageAddress) {
            throw new Error(`No Warm Storage address configured for network: ${network}`);
        }
        const warmStorageService = await WarmStorageService.create(provider, warmStorageAddress);
        const paymentsAddress = warmStorageService.getPaymentsAddress();
        const usdfcAddress = warmStorageService.getUSDFCTokenAddress();
        const payments = new PaymentsService(provider, signer, paymentsAddress, usdfcAddress, options.disableNonceManager === true);
        const registryAddress = warmStorageService.getServiceProviderRegistryAddress();
        const spRegistry = new SPRegistryService(provider, registryAddress);
        let pieceRetriever;
        if (options.pieceRetriever != null) {
            pieceRetriever = options.pieceRetriever;
        }
        else {
            const chainRetriever = new ChainRetriever(warmStorageService, spRegistry);
            let baseRetriever = chainRetriever;
            if (options.subgraphConfig != null || options.subgraphService != null) {
                const subgraphService = options.subgraphService != null
                    ? options.subgraphService
                    : new SubgraphService(options.subgraphConfig);
                baseRetriever = new SubgraphRetriever(subgraphService);
            }
            pieceRetriever = new FilCdnRetriever(baseRetriever, network);
        }
        return new Synapse(signer, provider, network, payments, options.withCDN === true, warmStorageAddress, warmStorageService, pieceRetriever);
    }
    constructor(signer, provider, network, payments, withCDN, warmStorageAddress, warmStorageService, pieceRetriever) {
        this._signer = signer;
        this._provider = provider;
        this._network = network;
        this._payments = payments;
        this._withCDN = withCDN;
        this._warmStorageService = warmStorageService;
        this._pieceRetriever = pieceRetriever;
        this._warmStorageAddress = warmStorageAddress;
        this._storageManager = new StorageManager(this, this._warmStorageService, this._pieceRetriever, this._withCDN);
    }
    getNetwork() {
        return this._network;
    }
    getSigner() {
        return this._signer;
    }
    getProvider() {
        return this._provider;
    }
    getChainId() {
        return this._network === 'mainnet' ? CHAIN_IDS.mainnet : CHAIN_IDS.calibration;
    }
    getWarmStorageAddress() {
        return this._warmStorageAddress;
    }
    getPaymentsAddress() {
        return this._warmStorageService.getPaymentsAddress();
    }
    getPDPVerifierAddress() {
        return this._warmStorageService.getPDPVerifierAddress();
    }
    get payments() {
        return this._payments;
    }
    get storage() {
        return this._storageManager;
    }
    async createStorage(options = {}) {
        return await this._storageManager.createContext(options);
    }
    async download(pieceCid, options) {
        console.warn('synapse.download() is deprecated. Use synapse.storage.download() instead.');
        return await this._storageManager.download(pieceCid, options);
    }
    async getProviderInfo(providerAddress) {
        try {
            if (typeof providerAddress === 'string') {
                try {
                    ethers.getAddress(providerAddress);
                }
                catch {
                    throw new Error(`Invalid provider address: ${providerAddress}`);
                }
            }
            const registryAddress = this._warmStorageService.getServiceProviderRegistryAddress();
            const spRegistry = new SPRegistryService(this._provider, registryAddress);
            const resolver = new ProviderResolver(this._warmStorageService, spRegistry);
            let providerInfo;
            if (typeof providerAddress === 'string') {
                providerInfo = await resolver.getApprovedProviderByAddress(providerAddress);
            }
            else {
                providerInfo = await resolver.getApprovedProvider(providerAddress);
            }
            if (providerInfo == null) {
                throw new Error(`Provider ${providerAddress} not found or not approved`);
            }
            return providerInfo;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('Invalid provider address')) {
                throw error;
            }
            if (error instanceof Error && error.message.includes('is not approved')) {
                throw error;
            }
            if (error instanceof Error && error.message.includes('not found')) {
                throw error;
            }
            throw new Error(`Failed to get provider info: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async getStorageInfo() {
        console.warn('synapse.getStorageInfo() is deprecated. Use synapse.storage.getStorageInfo() instead.');
        return await this._storageManager.getStorageInfo();
    }
}
//# sourceMappingURL=synapse.js.map