import { fromHex, toHex } from 'multiformats/bytes';
import { CID } from 'multiformats/cid';
import { asPieceCID } from "../piece/index.js";
import { createError } from "../utils/errors.js";
import { QUERIES } from "./queries.js";
export class SubgraphService {
    endpoint;
    headers;
    constructor(subgraphConfig) {
        this.endpoint = this.resolveEndpoint(subgraphConfig);
        this.headers = this.buildHeaders(subgraphConfig.apiKey);
    }
    resolveEndpoint(config) {
        if (config.endpoint != null && config.endpoint.trim() !== '') {
            return config.endpoint.trim();
        }
        if (config.goldsky != null) {
            return this.buildGoldskyEndpoint(config.goldsky);
        }
        throw createError('SubgraphService', 'constructor', 'Invalid configuration: provide either endpoint or complete goldsky config');
    }
    buildGoldskyEndpoint(goldsky) {
        const { projectId, subgraphName, version } = goldsky;
        if (projectId?.trim() == null ||
            projectId?.trim() === '' ||
            subgraphName?.trim() == null ||
            subgraphName?.trim() === '' ||
            version?.trim() == null ||
            version?.trim() === '') {
            throw createError('SubgraphService', 'constructor', 'Incomplete Goldsky config: projectId, subgraphName, and version required');
        }
        return `https://api.goldsky.com/api/public/${projectId}/subgraphs/${subgraphName}/${version}/gn`;
    }
    buildHeaders(apiKey) {
        const headers = { 'Content-Type': 'application/json' };
        if (apiKey != null && apiKey !== '') {
            return { ...headers, Authorization: `Bearer ${apiKey}` };
        }
        return headers;
    }
    normalizeQueryOptions(options = {}) {
        return {
            where: {},
            first: 10,
            skip: 0,
            orderBy: 'createdAt',
            orderDirection: 'desc',
            ...options,
        };
    }
    async executeQuery(query, variables, operation) {
        try {
            const response = await fetch(this.endpoint, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify({ query, variables }),
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw createError('SubgraphService', operation, `HTTP ${response.status}: ${errorText}`);
            }
            const result = (await response.json());
            if (result.errors != null && result.errors.length > 0) {
                const errorMsg = result.errors.map((e) => e.message).join('; ');
                throw createError('SubgraphService', operation, `GraphQL errors: ${errorMsg}`);
            }
            return result.data;
        }
        catch (error) {
            if (error instanceof Error && error.name === 'SynapseError') {
                throw error;
            }
            throw createError('SubgraphService', operation, `Query execution failed: ${error.message}`, {
                cause: error,
            });
        }
    }
    transformProviderData(data) {
        const serviceURL = data.serviceURL ?? data.pdpUrl ?? 'https://unknown.provider';
        return {
            id: 1,
            serviceProvider: data.serviceProvider ?? data.serviceProvider ?? data.id,
            payee: data.payee ?? data.serviceProvider ?? data.id,
            name: 'Subgraph Provider',
            description: 'Provider from subgraph',
            active: true,
            products: {
                PDP: {
                    type: 'PDP',
                    isActive: true,
                    capabilities: {},
                    data: {
                        serviceURL,
                        minPieceSizeInBytes: BigInt(1024),
                        maxPieceSizeInBytes: BigInt(1024 * 1024 * 1024),
                        ipniPiece: false,
                        ipniIpfs: false,
                        storagePricePerTibPerMonth: BigInt(1000000),
                        minProvingPeriodInEpochs: 2880,
                        location: 'Unknown',
                        paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                    },
                },
            },
        };
    }
    parseTimestamp(value) {
        if (value == null)
            return 0;
        const parsed = Number(value);
        return Number.isNaN(parsed) ? 0 : parsed;
    }
    safeConvertHexToCid(hexCid) {
        try {
            const cleanHex = hexCid.startsWith('0x') ? hexCid.slice(2) : hexCid;
            const cidBytes = fromHex(cleanHex);
            const cid = CID.decode(cidBytes);
            const pieceCid = asPieceCID(cid);
            if (pieceCid == null) {
                throw new Error(`Failed to convert CID to PieceCID format: ${hexCid}`);
            }
            return pieceCid;
        }
        catch (error) {
            console.warn(`SubgraphService: queryProviders: Failed to convert CID to PieceCID format: ${error instanceof Error ? error.message : 'Unknown error'}`);
            return null;
        }
    }
    isValidProviderData(data) {
        return data?.id != null && data.id.trim() !== '' && data?.serviceURL != null && data.serviceURL.trim() !== '';
    }
    async getApprovedProvidersForPieceCID(pieceCid) {
        const pieceCidParsed = asPieceCID(pieceCid);
        if (pieceCidParsed == null) {
            throw createError('SubgraphService', 'getApprovedProvidersForPieceCID', 'Invalid PieceCID');
        }
        const hexPieceCid = toHex(pieceCidParsed.bytes);
        const data = await this.executeQuery(QUERIES.GET_APPROVED_PROVIDERS_FOR_PIECE_LINK, { cid: hexPieceCid }, 'getApprovedProvidersForPieceCID');
        if (data?.pieces == null || data.pieces.length === 0) {
            console.log(`SubgraphService: No providers found for PieceCID: ${pieceCidParsed.toString()}`);
            return [];
        }
        const uniqueProviderMap = data.pieces.reduce((acc, piece) => {
            const provider = piece.dataSet.serviceProvider;
            const address = provider?.serviceProvider?.toLowerCase();
            if (provider?.status !== 'Approved' || address == null || address === '' || acc.has(address)) {
                return acc;
            }
            if (!this.isValidProviderData(provider)) {
                console.warn('SubgraphService: Skipping incomplete provider data for approved provider:', provider);
                return acc;
            }
            acc.set(address, provider);
            return acc;
        }, new Map());
        return Array.from(uniqueProviderMap.values()).map((provider) => this.transformProviderData(provider));
    }
    async getProviderByAddress(address) {
        const data = await this.executeQuery(QUERIES.GET_PROVIDER_BY_ADDRESS, { providerId: address }, 'getProviderByAddress');
        if (data?.provider == null) {
            console.log(`SubgraphService: No provider found for address: ${address}`);
            return null;
        }
        return this.transformProviderData(data.provider);
    }
    async queryProviders(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_PROVIDERS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryProviders');
        if (data?.providers == null || data?.providers?.length === 0) {
            console.log('SubgraphService: No providers found for the given criteria');
            return [];
        }
        return data.providers
            .filter((provider) => this.isValidProviderData(provider))
            .map((provider) => this.transformProviderData(provider));
    }
    async queryDataSets(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_DATA_SETS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryDataSets');
        if (data?.dataSets == null || data?.dataSets?.length === 0) {
            console.log('SubgraphService: No data sets found for the given criteria');
            return [];
        }
        return data.dataSets.map((dataSet) => ({
            id: dataSet.id,
            setId: this.parseTimestamp(dataSet.setId),
            listener: dataSet.listener ?? '',
            clientAddr: dataSet.clientAddr ?? '',
            withCDN: dataSet.withCDN ?? false,
            isActive: dataSet.isActive,
            leafCount: this.parseTimestamp(dataSet.leafCount),
            challengeRange: this.parseTimestamp(dataSet.challengeRange),
            lastProvenEpoch: this.parseTimestamp(dataSet.lastProvenEpoch),
            nextChallengeEpoch: this.parseTimestamp(dataSet.nextChallengeEpoch),
            totalPieces: this.parseTimestamp(dataSet.totalPieces),
            totalDataSize: this.parseTimestamp(dataSet.totalDataSize),
            totalProofs: this.parseTimestamp(dataSet.totalProofs),
            totalProvedPieces: this.parseTimestamp(dataSet.totalProvedPieces),
            totalFaultedPeriods: this.parseTimestamp(dataSet.totalFaultedPeriods),
            totalFaultedPieces: this.parseTimestamp(dataSet.totalFaultedPieces),
            metadata: dataSet.metadata ?? '',
            createdAt: this.parseTimestamp(dataSet.createdAt),
            updatedAt: this.parseTimestamp(dataSet.updatedAt),
            owner: dataSet.owner != null ? this.transformProviderData(dataSet.owner) : this.transformProviderData({}),
            serviceProvider: dataSet.serviceProvider != null
                ? this.transformProviderData(dataSet.serviceProvider)
                : this.transformProviderData({}),
            rail: dataSet.rail != null
                ? {
                    id: dataSet.rail.id,
                    railId: this.parseTimestamp(dataSet.rail.railId),
                    token: dataSet.rail.token,
                    paymentRate: this.parseTimestamp(dataSet.rail.paymentRate),
                    lockupPeriod: this.parseTimestamp(dataSet.rail.lockupPeriod),
                    settledUpto: this.parseTimestamp(dataSet.rail.settledUpto),
                    endEpoch: this.parseTimestamp(dataSet.rail.endEpoch),
                }
                : undefined,
        }));
    }
    async queryPieces(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_PIECES_FLEXIBLE, this.normalizeQueryOptions(options), 'queryPieces');
        if (data?.pieces == null || data?.pieces?.length === 0) {
            console.log('SubgraphService: No pieces found for the given criteria');
            return [];
        }
        return data.pieces.map((piece) => ({
            id: piece.id,
            setId: this.parseTimestamp(piece.setId),
            pieceId: this.parseTimestamp(piece.pieceId),
            rawSize: this.parseTimestamp(piece.rawSize),
            leafCount: this.parseTimestamp(piece.leafCount),
            cid: this.safeConvertHexToCid(piece.cid),
            removed: piece.removed,
            totalProofsSubmitted: this.parseTimestamp(piece.totalProofsSubmitted),
            totalPeriodsFaulted: this.parseTimestamp(piece.totalPeriodsFaulted),
            lastProvenEpoch: this.parseTimestamp(piece.lastProvenEpoch),
            lastProvenAt: this.parseTimestamp(piece.lastProvenAt),
            lastFaultedEpoch: this.parseTimestamp(piece.lastFaultedEpoch),
            lastFaultedAt: this.parseTimestamp(piece.lastFaultedAt),
            createdAt: this.parseTimestamp(piece.createdAt),
            metadata: piece.metadata ?? '',
            dataSet: {
                id: piece.dataSet.id,
                setId: this.parseTimestamp(piece.dataSet.setId),
                isActive: piece.dataSet.isActive,
                serviceProvider: this.transformProviderData(piece.dataSet.serviceProvider),
            },
        }));
    }
    async queryFaultRecords(options = {}) {
        const data = await this.executeQuery(QUERIES.GET_FAULT_RECORDS_FLEXIBLE, this.normalizeQueryOptions(options), 'queryFaultRecords');
        if (data?.faultRecords == null || data?.faultRecords?.length === 0) {
            console.log('SubgraphService: No fault records found for the given criteria');
            return [];
        }
        return data.faultRecords.map((fault) => ({
            id: fault.id,
            dataSetId: this.parseTimestamp(fault.dataSetId),
            pieceIds: fault.pieceIds.map((id) => this.parseTimestamp(id)),
            currentChallengeEpoch: this.parseTimestamp(fault.currentChallengeEpoch),
            nextChallengeEpoch: this.parseTimestamp(fault.nextChallengeEpoch),
            periodsFaulted: this.parseTimestamp(fault.periodsFaulted),
            deadline: this.parseTimestamp(fault.deadline),
            createdAt: this.parseTimestamp(fault.createdAt),
            dataSet: {
                id: fault.dataSet.id,
                setId: this.parseTimestamp(fault.dataSet.setId),
                serviceProvider: this.transformProviderData(fault.dataSet.serviceProvider),
            },
        }));
    }
}
//# sourceMappingURL=service.js.map