import { ethers } from 'ethers';
import { asPieceCID } from "../piece/index.js";
import { METADATA_KEYS } from "../utils/constants.js";
const EIP712_TYPES = {
    MetadataEntry: [
        { name: 'key', type: 'string' },
        { name: 'value', type: 'string' },
    ],
    CreateDataSet: [
        { name: 'clientDataSetId', type: 'uint256' },
        { name: 'payee', type: 'address' },
        { name: 'metadata', type: 'MetadataEntry[]' },
    ],
    Cid: [{ name: 'data', type: 'bytes' }],
    PieceMetadata: [
        { name: 'pieceIndex', type: 'uint256' },
        { name: 'metadata', type: 'MetadataEntry[]' },
    ],
    AddPieces: [
        { name: 'clientDataSetId', type: 'uint256' },
        { name: 'firstAdded', type: 'uint256' },
        { name: 'pieceData', type: 'Cid[]' },
        { name: 'pieceMetadata', type: 'PieceMetadata[]' },
    ],
    SchedulePieceRemovals: [
        { name: 'clientDataSetId', type: 'uint256' },
        { name: 'pieceIds', type: 'uint256[]' },
    ],
    DeleteDataSet: [{ name: 'clientDataSetId', type: 'uint256' }],
};
export class PDPAuthHelper {
    signer;
    domain;
    WITH_CDN_METADATA = { key: METADATA_KEYS.WITH_CDN, value: '' };
    constructor(serviceContractAddress, signer, chainId) {
        this.signer = signer;
        this.domain = {
            name: 'FilecoinWarmStorageService',
            version: '1',
            chainId: Number(chainId),
            verifyingContract: serviceContractAddress,
        };
    }
    getUnderlyingSigner() {
        if ('signer' in this.signer && this.signer.constructor.name === 'NonceManager') {
            return this.signer.signer;
        }
        return this.signer;
    }
    async isMetaMaskSigner() {
        try {
            const actualSigner = this.getUnderlyingSigner();
            if (actualSigner.constructor.name === 'Wallet') {
                return false;
            }
            const provider = actualSigner.provider;
            if (provider == null) {
                return false;
            }
            if ('_eip1193Provider' in provider) {
                return true;
            }
            if (typeof globalThis !== 'undefined' && 'window' in globalThis) {
                const win = globalThis;
                if (win.window?.ethereum != null) {
                    return true;
                }
            }
            if ('send' in provider || 'request' in provider) {
                return true;
            }
        }
        catch {
        }
        return false;
    }
    async signWithMetaMask(types, value) {
        const provider = this.signer.provider;
        if (provider == null) {
            throw new Error('No provider available');
        }
        const signerAddress = await this.signer.getAddress();
        let primaryType = '';
        for (const typeName of Object.keys(types)) {
            if (typeName !== 'Cid' && typeName !== 'PieceData') {
                primaryType = typeName;
                break;
            }
        }
        const typedData = {
            types: {
                EIP712Domain: [
                    { name: 'name', type: 'string' },
                    { name: 'version', type: 'string' },
                    { name: 'chainId', type: 'uint256' },
                    { name: 'verifyingContract', type: 'address' },
                ],
                ...types,
            },
            primaryType,
            domain: this.domain,
            message: value,
        };
        let eip1193Provider;
        if ('_eip1193Provider' in provider) {
            eip1193Provider = provider._eip1193Provider;
        }
        else if ('request' in provider) {
            eip1193Provider = provider;
        }
        else {
            eip1193Provider = provider;
        }
        let signature;
        if (eip1193Provider != null && 'request' in eip1193Provider) {
            signature = await eip1193Provider.request({
                method: 'eth_signTypedData_v4',
                params: [signerAddress.toLowerCase(), JSON.stringify(typedData)],
            });
        }
        else {
            signature = await provider.send('eth_signTypedData_v4', [
                signerAddress.toLowerCase(),
                JSON.stringify(typedData),
            ]);
        }
        return signature;
    }
    async signCreateDataSet(clientDataSetId, payee, metadata = []) {
        let signature;
        const types = { CreateDataSet: EIP712_TYPES.CreateDataSet, MetadataEntry: EIP712_TYPES.MetadataEntry };
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                metadata,
                payee,
            };
            signature = await this.signWithMetaMask(types, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                metadata,
                payee,
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, types, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, types, {
            clientDataSetId: BigInt(clientDataSetId),
            metadata,
            payee,
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async signAddPieces(clientDataSetId, firstPieceId, pieceDataArray, metadata = []) {
        if (metadata.length === 0) {
            metadata = Array(pieceDataArray.length).fill([]);
        }
        else if (metadata.length !== pieceDataArray.length) {
            throw new Error('metadata length must match pieceDataArray length');
        }
        const pieceMetadata = [];
        const formattedPieceData = [];
        for (let i = 0; i < pieceDataArray.length; i++) {
            const piece = pieceDataArray[i];
            const pieceCid = typeof piece === 'string' ? asPieceCID(piece) : piece;
            if (pieceCid == null) {
                throw new Error(`Invalid PieceCID: ${String(pieceCid)}`);
            }
            formattedPieceData.push({
                data: pieceCid.bytes,
            });
            pieceMetadata.push({
                pieceIndex: i,
                metadata: metadata[i],
            });
        }
        const types = {
            AddPieces: EIP712_TYPES.AddPieces,
            Cid: EIP712_TYPES.Cid,
            PieceMetadata: EIP712_TYPES.PieceMetadata,
            MetadataEntry: EIP712_TYPES.MetadataEntry,
        };
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                firstAdded: firstPieceId.toString(),
                pieceData: formattedPieceData.map((item) => ({
                    data: ethers.hexlify(item.data),
                })),
                pieceMetadata: pieceMetadata,
            };
            signature = await this.signWithMetaMask(types, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                firstAdded: BigInt(firstPieceId),
                pieceData: formattedPieceData,
                pieceMetadata: pieceMetadata,
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, types, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, types, {
            clientDataSetId: BigInt(clientDataSetId),
            firstAdded: BigInt(firstPieceId),
            pieceData: formattedPieceData,
            pieceMetadata: pieceMetadata,
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async signSchedulePieceRemovals(clientDataSetId, pieceIds) {
        const pieceIdsBigInt = pieceIds.map((id) => BigInt(id));
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
                pieceIds: pieceIdsBigInt.map((id) => id.toString()),
            };
            signature = await this.signWithMetaMask({ SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals }, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
                pieceIds: pieceIdsBigInt,
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, { SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals }, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, { SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals }, {
            clientDataSetId: BigInt(clientDataSetId),
            pieceIds: pieceIdsBigInt,
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async signDeleteDataSet(clientDataSetId) {
        let signature;
        const useMetaMask = await this.isMetaMaskSigner();
        if (useMetaMask) {
            const value = {
                clientDataSetId: clientDataSetId.toString(),
            };
            signature = await this.signWithMetaMask({ DeleteDataSet: EIP712_TYPES.DeleteDataSet }, value);
        }
        else {
            const value = {
                clientDataSetId: BigInt(clientDataSetId),
            };
            const actualSigner = this.getUnderlyingSigner();
            signature = await actualSigner.signTypedData(this.domain, { DeleteDataSet: EIP712_TYPES.DeleteDataSet }, value);
        }
        const sig = ethers.Signature.from(signature);
        const signedData = ethers.TypedDataEncoder.hash(this.domain, { DeleteDataSet: EIP712_TYPES.DeleteDataSet }, {
            clientDataSetId: BigInt(clientDataSetId),
        });
        return {
            signature,
            v: sig.v,
            r: sig.r,
            s: sig.s,
            signedData,
        };
    }
    async getSignerAddress() {
        return await this.signer.getAddress();
    }
}
//# sourceMappingURL=auth.js.map