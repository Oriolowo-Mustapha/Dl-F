import { ethers } from 'ethers';
import { CONTRACT_ABIS, CONTRACT_ADDRESSES } from "../utils/constants.js";
import { getFilecoinNetworkType } from "../utils/index.js";
export class ProviderResolver {
    warmStorage;
    spRegistry;
    constructor(warmStorage, spRegistry) {
        this.warmStorage = warmStorage;
        this.spRegistry = spRegistry;
    }
    async getApprovedProviders(limit = 50) {
        const approvedIds = await this.warmStorage.getApprovedProviderIds();
        if (approvedIds.length <= limit) {
            return await this.spRegistry.getProviders(approvedIds);
        }
        const allProviders = [];
        let offset = 0;
        while (offset < approvedIds.length) {
            const batch = approvedIds.slice(offset, offset + limit);
            const providers = await this.spRegistry.getProviders(batch);
            allProviders.push(...providers);
            offset += limit;
        }
        return allProviders;
    }
    async getApprovedProvider(providerId) {
        const isApproved = await this.warmStorage.isProviderIdApproved(providerId);
        if (!isApproved)
            return null;
        return await this.spRegistry.getProvider(providerId);
    }
    async getApprovedProvidersByIds(providerIds) {
        if (providerIds.length === 0)
            return [];
        try {
            const provider = this.warmStorage.getProvider();
            const network = await getFilecoinNetworkType(provider);
            const multicall3Address = CONTRACT_ADDRESSES.MULTICALL3[network];
            const multicall = new ethers.Contract(multicall3Address, CONTRACT_ABIS.MULTICALL3, provider);
            const warmStorageViewAddress = this.warmStorage.getViewContractAddress();
            const iface = new ethers.Interface(CONTRACT_ABIS.WARM_STORAGE_VIEW);
            const approvalCalls = providerIds.map((id) => ({
                target: warmStorageViewAddress,
                allowFailure: true,
                callData: iface.encodeFunctionData('isProviderApproved', [id]),
            }));
            const approvalResults = await multicall.aggregate3.staticCall(approvalCalls);
            const approvalChecks = approvalResults.map((result) => {
                if (!result.success)
                    return false;
                try {
                    const decoded = iface.decodeFunctionResult('isProviderApproved', result.returnData);
                    return decoded[0];
                }
                catch {
                    return false;
                }
            });
            const approvedIds = providerIds.filter((_, index) => approvalChecks[index]);
            if (approvedIds.length === 0) {
                return providerIds.map(() => null);
            }
            const providers = await this.spRegistry.getProviders(approvedIds);
            const providerMap = new Map();
            for (const provider of providers) {
                providerMap.set(provider.id, provider);
            }
            return providerIds.map((id, index) => {
                if (!approvalChecks[index])
                    return null;
                return providerMap.get(id) ?? null;
            });
        }
        catch {
            const approvalChecks = await Promise.all(providerIds.map((id) => this.warmStorage.isProviderIdApproved(id)));
            const approvedIds = providerIds.filter((_, index) => approvalChecks[index]);
            if (approvedIds.length === 0) {
                return providerIds.map(() => null);
            }
            const providers = await this.spRegistry.getProviders(approvedIds);
            const providerMap = new Map();
            for (const provider of providers) {
                providerMap.set(provider.id, provider);
            }
            return providerIds.map((id, index) => {
                if (!approvalChecks[index])
                    return null;
                return providerMap.get(id) ?? null;
            });
        }
    }
    async getApprovedProviderByAddress(address) {
        const provider = await this.spRegistry.getProviderByAddress(address);
        if (provider == null)
            return null;
        const isApproved = await this.warmStorage.isProviderIdApproved(provider.id);
        return isApproved ? provider : null;
    }
    async isProviderApproved(providerId) {
        const isApproved = await this.warmStorage.isProviderIdApproved(providerId);
        if (!isApproved)
            return false;
        const isActive = await this.spRegistry.isProviderActive(providerId);
        return isActive;
    }
}
//# sourceMappingURL=provider-resolver.js.map