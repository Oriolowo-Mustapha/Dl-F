import { GENESIS_TIMESTAMPS, TIME_CONSTANTS } from "./constants.js";
import { createError } from "./errors.js";
export function epochToDate(epoch, network) {
    const genesisTimestamp = GENESIS_TIMESTAMPS[network];
    const epochDuration = TIME_CONSTANTS.EPOCH_DURATION;
    const timestampSeconds = genesisTimestamp + epoch * epochDuration;
    return new Date(timestampSeconds * 1000);
}
export function dateToEpoch(date, network) {
    const genesisTimestamp = GENESIS_TIMESTAMPS[network];
    const epochDuration = TIME_CONSTANTS.EPOCH_DURATION;
    const timestampSeconds = Math.floor(date.getTime() / 1000);
    const secondsSinceGenesis = timestampSeconds - genesisTimestamp;
    return Math.floor(secondsSinceGenesis / epochDuration);
}
export function getGenesisTimestamp(network) {
    return GENESIS_TIMESTAMPS[network];
}
export function timeUntilEpoch(futureEpoch, currentEpoch) {
    const epochDifference = futureEpoch - currentEpoch;
    const seconds = epochDifference * TIME_CONSTANTS.EPOCH_DURATION;
    return {
        epochs: epochDifference,
        seconds,
        minutes: seconds / 60,
        hours: seconds / 3600,
        days: seconds / 86400,
    };
}
export function calculateLastProofDate(nextChallengeEpoch, maxProvingPeriod, network) {
    if (nextChallengeEpoch === 0) {
        return null;
    }
    const lastProofEpoch = nextChallengeEpoch - maxProvingPeriod;
    if (lastProofEpoch <= 0) {
        return null;
    }
    return epochToDate(lastProofEpoch, network);
}
export async function getCurrentEpoch(provider) {
    const blockNumber = await provider.getBlockNumber();
    if (blockNumber == null) {
        throw createError('epoch', 'getCurrentEpoch', 'Failed to get latest block number');
    }
    return BigInt(blockNumber);
}
//# sourceMappingURL=epoch.js.map