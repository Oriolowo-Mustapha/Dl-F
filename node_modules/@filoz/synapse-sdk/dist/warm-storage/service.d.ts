import { ethers } from 'ethers';
import type { PaymentsService } from '../payments/service.ts';
import type { DataSetCreationStatusResponse, PDPServer } from '../pdp/server.ts';
import type { DataSetInfo, EnhancedDataSetInfo } from '../types.ts';
export interface AddPiecesInfo {
    nextPieceId: number;
    clientDataSetId: number;
    currentPieceCount: number;
}
export interface ServicePriceInfo {
    pricePerTiBPerMonthNoCDN: bigint;
    pricePerTiBPerMonthWithCDN: bigint;
    tokenAddress: string;
    epochsPerMonth: bigint;
}
export interface DataSetCreationVerification {
    transactionMined: boolean;
    transactionSuccess: boolean;
    dataSetId?: number;
    dataSetLive: boolean;
    blockNumber?: number;
    gasUsed?: bigint;
    error?: string;
}
export interface ComprehensiveDataSetStatus {
    txHash: string;
    serverStatus: DataSetCreationStatusResponse | null;
    chainStatus: DataSetCreationVerification;
    summary: {
        isComplete: boolean;
        isLive: boolean;
        dataSetId: number | null;
        error: string | null;
    };
}
export declare class WarmStorageService {
    private readonly _provider;
    private readonly _warmStorageAddress;
    private _warmStorageContract;
    private _warmStorageViewContract;
    private _pdpVerifier;
    private readonly _addresses;
    private constructor();
    static create(provider: ethers.Provider, warmStorageAddress: string): Promise<WarmStorageService>;
    getPDPVerifierAddress(): string;
    getPaymentsAddress(): string;
    getUSDFCTokenAddress(): string;
    getViewContractAddress(): string;
    getServiceProviderRegistryAddress(): string;
    getProvider(): ethers.Provider;
    private _getWarmStorageContract;
    private _getWarmStorageViewContract;
    private _getPDPVerifier;
    getDataSet(dataSetId: number): Promise<DataSetInfo>;
    getClientDataSets(clientAddress: string): Promise<DataSetInfo[]>;
    getClientDataSetsWithDetails(client: string, onlyManaged?: boolean): Promise<EnhancedDataSetInfo[]>;
    getAddPiecesInfo(dataSetId: number): Promise<AddPiecesInfo>;
    getNextClientDataSetId(clientAddress: string): Promise<number>;
    verifyDataSetCreation(txHashOrTransaction: string | ethers.TransactionResponse): Promise<DataSetCreationVerification>;
    getComprehensiveDataSetStatus(txHashOrTransaction: string | ethers.TransactionResponse, pdpServer?: PDPServer): Promise<ComprehensiveDataSetStatus>;
    waitForDataSetCreationWithStatus(txHashOrTransaction: string | ethers.TransactionResponse, pdpServer: PDPServer, maxWaitTime?: number, pollInterval?: number, onProgress?: (status: ComprehensiveDataSetStatus, elapsedMs: number) => Promise<void>): Promise<ComprehensiveDataSetStatus>;
    getDataSetMetadata(dataSetId: number): Promise<Record<string, string>>;
    getDataSetMetadataByKey(dataSetId: number, key: string): Promise<string | null>;
    getPieceMetadata(dataSetId: number, pieceId: number): Promise<Record<string, string>>;
    getPieceMetadataByKey(dataSetId: number, pieceId: number, key: string): Promise<string | null>;
    getServicePrice(): Promise<ServicePriceInfo>;
    calculateStorageCost(sizeInBytes: number): Promise<{
        perEpoch: bigint;
        perDay: bigint;
        perMonth: bigint;
        withCDN: {
            perEpoch: bigint;
            perDay: bigint;
            perMonth: bigint;
        };
    }>;
    checkAllowanceForStorage(sizeInBytes: number, withCDN: boolean, paymentsService: PaymentsService, lockupDays?: number): Promise<{
        rateAllowanceNeeded: bigint;
        lockupAllowanceNeeded: bigint;
        currentRateAllowance: bigint;
        currentLockupAllowance: bigint;
        currentRateUsed: bigint;
        currentLockupUsed: bigint;
        sufficient: boolean;
        message?: string;
        costs: {
            perEpoch: bigint;
            perDay: bigint;
            perMonth: bigint;
        };
        depositAmountNeeded: bigint;
    }>;
    prepareStorageUpload(options: {
        dataSize: number;
        withCDN?: boolean;
    }, paymentsService: PaymentsService): Promise<{
        estimatedCost: {
            perEpoch: bigint;
            perDay: bigint;
            perMonth: bigint;
        };
        allowanceCheck: {
            sufficient: boolean;
            message?: string;
        };
        actions: Array<{
            type: 'deposit' | 'approve' | 'approveService';
            description: string;
            execute: () => Promise<ethers.TransactionResponse>;
        }>;
    }>;
    terminateDataSet(signer: ethers.Signer, dataSetId: number): Promise<ethers.TransactionResponse>;
    addApprovedProvider(signer: ethers.Signer, providerId: number): Promise<ethers.TransactionResponse>;
    removeApprovedProvider(signer: ethers.Signer, providerId: number): Promise<ethers.TransactionResponse>;
    getApprovedProviderIds(): Promise<number[]>;
    isProviderIdApproved(providerId: number): Promise<boolean>;
    getOwner(): Promise<string>;
    isOwner(signer: ethers.Signer): Promise<boolean>;
    getMaxProvingPeriod(): Promise<number>;
    getChallengeWindow(): Promise<number>;
}
//# sourceMappingURL=service.d.ts.map