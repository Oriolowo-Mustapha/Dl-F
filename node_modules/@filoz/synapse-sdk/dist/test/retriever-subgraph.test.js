import { assert } from 'chai';
import { asPieceCID } from "../piece/index.js";
import { SubgraphRetriever } from "../retriever/subgraph.js";
import { SubgraphService } from "../subgraph/index.js";
import { createSimpleProvider } from "./test-utils.js";
const mockPieceCID = asPieceCID('bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace');
const mockProvider = createSimpleProvider({
    serviceProvider: '0x1234567890123456789012345678901234567890',
    serviceURL: 'https://provider.example.com',
});
const mockChildRetriever = {
    fetchPiece: async (_pieceCid, _client, _options) => {
        return new Response('data from child', { status: 200 });
    },
};
const createMockSubgraphService = (providersToReturn) => {
    const mockService = {
        getApprovedProvidersForPieceCID: async (_pieceCid) => {
            if (providersToReturn instanceof Error) {
                throw providersToReturn;
            }
            return providersToReturn ?? [];
        },
        getProviderByAddress: async (address) => {
            const providers = providersToReturn instanceof Error ? [] : (providersToReturn ?? []);
            return providers.find((p) => p.serviceProvider === address) ?? null;
        },
    };
    return mockService;
};
describe('SubgraphRetriever', () => {
    describe('constructor', () => {
        it('should initialize with a SubgraphService (direct endpoint config for service)', () => {
            const config = { endpoint: 'https://test.com/graphql' };
            const service = new SubgraphService(config);
            const retriever = new SubgraphRetriever(service);
            assert.isNotNull(retriever);
        });
        it('should initialize with a SubgraphService (Goldsky config for service)', () => {
            const config = {
                goldsky: {
                    projectId: 'test-project',
                    subgraphName: 'test-subgraph',
                    version: 'v1',
                },
            };
            const service = new SubgraphService(config);
            const retriever = new SubgraphRetriever(service);
            assert.isNotNull(retriever);
        });
        it('SubgraphService should throw an error for incomplete Goldsky configuration', () => {
            assert.throws(() => {
                const config = {
                    goldsky: { projectId: 'test', subgraphName: '', version: '' },
                };
                new SubgraphService(config);
            }, /Incomplete Goldsky config: projectId, subgraphName, and version required/);
        });
        it('SubgraphService should throw an error for empty configuration', () => {
            assert.throws(() => {
                const config = {};
                new SubgraphService(config);
            }, /Invalid configuration: provide either endpoint or complete goldsky config/);
        });
    });
    describe('fetchPiece', () => {
        let originalFetch;
        beforeEach(() => {
            originalFetch = global.fetch;
        });
        afterEach(() => {
            global.fetch = originalFetch;
        });
        it('should fetch a piece from a provider found via SubgraphService', async () => {
            const mockService = createMockSubgraphService([mockProvider]);
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes(mockProvider.products.PDP?.data.serviceURL || '')) {
                    if (url.includes('/piece/')) {
                        return new Response('piece data', { status: 200 });
                    }
                    return new Response(null, { status: 200 });
                }
                throw new Error(`Unexpected fetch call to ${url}`);
            };
            const retriever = new SubgraphRetriever(mockService);
            const response = await retriever.fetchPiece(mockPieceCID, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'piece data');
        });
        it('should fall back to child retriever when SubgraphService returns no providers', async () => {
            const mockService = createMockSubgraphService([]);
            const retriever = new SubgraphRetriever(mockService, mockChildRetriever);
            const response = await retriever.fetchPiece(mockPieceCID, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should fall back to child retriever when fetching from subgraph providers (found by service) fails', async () => {
            const mockService = createMockSubgraphService([mockProvider]);
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes(mockProvider.products.PDP?.data.serviceURL || '') ||
                    url.includes(mockProvider.products.PDP?.data.serviceURL || '')) {
                    return new Response('provider error', { status: 500 });
                }
                throw new Error(`Unexpected fetch call to ${url}`);
            };
            const retriever = new SubgraphRetriever(mockService, mockChildRetriever);
            const response = await retriever.fetchPiece(mockPieceCID, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should filter by providerAddress when provided (providers from service)', async () => {
            const otherProvider = {
                ...mockProvider,
                serviceProvider: '0xother',
            };
            const mockService = createMockSubgraphService([mockProvider, otherProvider]);
            let fetchCalledForMockProvider = false;
            let fetchCalledForOtherProvider = false;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes(mockProvider.products.PDP?.data.serviceURL || '')) {
                    fetchCalledForMockProvider = true;
                    return new Response('piece data', { status: 200 });
                }
                if (url.includes(otherProvider.products.PDP?.data.serviceURL || '')) {
                    fetchCalledForOtherProvider = true;
                    return new Response('other piece data', { status: 200 });
                }
                if (url.includes('/pdp')) {
                    return new Response(null, { status: 200 });
                }
                throw new Error(`Unexpected fetch call to ${url}`);
            };
            const retriever = new SubgraphRetriever(mockService);
            await retriever.fetchPiece(mockPieceCID, 'client1', {
                providerAddress: mockProvider.serviceProvider,
            });
            assert.isTrue(fetchCalledForMockProvider, 'Should have fetched from the specified provider');
            assert.isFalse(fetchCalledForOtherProvider, 'Should NOT have fetched from the other provider');
        });
        it('should throw an error if all attempts fail (service provides provider, but fetch fails) and no child', async () => {
            const mockService = createMockSubgraphService([mockProvider]);
            global.fetch = async () => {
                return new Response('error', { status: 500 });
            };
            const retriever = new SubgraphRetriever(mockService);
            try {
                await retriever.fetchPiece(mockPieceCID, 'client1');
                assert.fail('Should have thrown an error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to retrieve piece');
            }
        });
        it('should throw an error if service returns no providers and no child retriever', async () => {
            const mockService = createMockSubgraphService([]);
            const retriever = new SubgraphRetriever(mockService);
            try {
                await retriever.fetchPiece(mockPieceCID, 'client1');
                assert.fail('Should have thrown an error');
            }
            catch (error) {
                assert.include(error.message, 'Failed to retrieve piece');
                assert.include(error.message, 'No providers found and no additional retriever method was configured');
            }
        });
        it('should fall back if SubgraphService effectively returns empty (e.g. due to internal GraphQL error)', async () => {
            const mockService = createMockSubgraphService([]);
            const retriever = new SubgraphRetriever(mockService, mockChildRetriever);
            const response = await retriever.fetchPiece(mockPieceCID, 'client1');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
    });
});
//# sourceMappingURL=retriever-subgraph.test.js.map