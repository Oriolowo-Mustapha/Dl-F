import { assert } from 'chai';
import { asPieceCID } from "../piece/index.js";
import { ChainRetriever } from "../retriever/chain.js";
const mockPieceCID = asPieceCID('bafkzcibeqcad6efnpwn62p5vvs5x3nh3j7xkzfgb3xtitcdm2hulmty3xx4tl3wace');
const mockProvider1 = {
    id: 1,
    serviceProvider: '0x1234567890123456789012345678901234567890',
    payee: '0x1234567890123456789012345678901234567890',
    name: 'Provider 1',
    description: 'Test provider 1',
    active: true,
    products: {
        PDP: {
            type: 'PDP',
            isActive: true,
            capabilities: {},
            data: {
                serviceURL: 'https://provider1.example.com',
                minPieceSizeInBytes: BigInt(1024),
                maxPieceSizeInBytes: BigInt(32) * BigInt(1024) * BigInt(1024) * BigInt(1024),
                ipniPiece: false,
                ipniIpfs: false,
                storagePricePerTibPerMonth: BigInt(1000000),
                minProvingPeriodInEpochs: 30,
                location: 'us-east',
                paymentTokenAddress: '0x0000000000000000000000000000000000000000',
            },
        },
    },
};
const mockProvider2 = {
    id: 2,
    serviceProvider: '0x2345678901234567890123456789012345678901',
    payee: '0x2345678901234567890123456789012345678901',
    name: 'Provider 2',
    description: 'Test provider 2',
    active: true,
    products: {
        PDP: {
            type: 'PDP',
            isActive: true,
            capabilities: {},
            data: {
                serviceURL: 'https://provider2.example.com',
                minPieceSizeInBytes: BigInt(1024),
                maxPieceSizeInBytes: BigInt(32) * BigInt(1024) * BigInt(1024) * BigInt(1024),
                ipniPiece: false,
                ipniIpfs: false,
                storagePricePerTibPerMonth: BigInt(1000000),
                minProvingPeriodInEpochs: 30,
                location: 'us-east',
                paymentTokenAddress: '0x0000000000000000000000000000000000000000',
            },
        },
    },
};
const mockChildRetriever = {
    fetchPiece: async (_pieceCid, _client, _options) => {
        return new Response('data from child', { status: 200 });
    },
};
const mockDataSet = {
    pdpRailId: 1,
    cacheMissRailId: 0,
    cdnRailId: 0,
    payer: '0xClient',
    payee: mockProvider1.serviceProvider,
    serviceProvider: mockProvider1.serviceProvider,
    commissionBps: 100,
    clientDataSetId: 1,
    pdpEndEpoch: 0,
    providerId: 1,
    cdnEndEpoch: 0,
    paymentEndEpoch: 0,
    withCDN: false,
    pdpVerifierDataSetId: 123,
    nextPieceId: 1,
    currentPieceCount: 5,
    isLive: true,
    isManaged: true,
    metadata: {},
};
describe('ChainRetriever', () => {
    describe('fetchPiece with specific provider', () => {
        it('should fetch from specific provider when providerAddress is given', async () => {
            const mockWarmStorage = {
                getProvider: () => null,
                isProviderIdApproved: async (providerId) => providerId === 1,
            };
            const mockSPRegistry = {
                getProviderByAddress: async (addr) => {
                    if (addr === mockProvider1.serviceProvider)
                        return mockProvider1;
                    return null;
                },
                getProvider: async (id) => {
                    if (id === 1)
                        return mockProvider1;
                    return null;
                },
            };
            const originalFetch = global.fetch;
            let findPieceCalled = false;
            let downloadCalled = false;
            global.fetch = async (input, _init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('/pdp/piece?')) {
                    findPieceCalled = true;
                    return new Response('', { status: 200 });
                }
                if (url.includes('/piece/')) {
                    downloadCalled = true;
                    return new Response('test data', { status: 200 });
                }
                throw new Error('Unexpected URL');
            };
            try {
                const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
                const response = await retriever.fetchPiece(mockPieceCID, '0xClient', {
                    providerAddress: mockProvider1.serviceProvider,
                });
                assert.isTrue(findPieceCalled, 'Should call findPiece');
                assert.isTrue(downloadCalled, 'Should call download');
                assert.equal(response.status, 200);
                assert.equal(await response.text(), 'test data');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should fall back to child retriever when specific provider is not approved', async () => {
            const mockWarmStorage = {
                getProvider: () => null,
                isProviderIdApproved: async () => false,
            };
            const mockSPRegistry = {
                getProviderByAddress: async () => null,
            };
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry, mockChildRetriever);
            const response = await retriever.fetchPiece(mockPieceCID, '0xClient', {
                providerAddress: '0xNotApproved',
            });
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should throw when specific provider is not approved and no child retriever', async () => {
            const mockWarmStorage = {
                getProvider: () => null,
                isProviderIdApproved: async () => false,
            };
            const mockSPRegistry = {
                getProviderByAddress: async () => null,
            };
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
            try {
                await retriever.fetchPiece(mockPieceCID, '0xClient', {
                    providerAddress: '0xNotApproved',
                });
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Provider 0xNotApproved not found or not approved');
            }
        });
    });
    describe('fetchPiece with multiple providers', () => {
        it('should wait for successful provider even if others fail first', async () => {
            const dataSets = [
                {
                    pdpRailId: 1,
                    cacheMissRailId: 0,
                    cdnRailId: 0,
                    payer: '0xClient',
                    payee: '0xProvider1',
                    commissionBps: 100,
                    clientDataSetId: 1,
                    paymentEndEpoch: 0,
                    providerId: 1,
                    isLive: true,
                    currentPieceCount: 1,
                },
                {
                    pdpRailId: 2,
                    cacheMissRailId: 0,
                    cdnRailId: 0,
                    payer: '0xClient',
                    payee: '0xProvider2',
                    commissionBps: 100,
                    clientDataSetId: 2,
                    paymentEndEpoch: 0,
                    providerId: 2,
                    isLive: true,
                    currentPieceCount: 1,
                },
            ];
            const providers = [
                {
                    id: 1,
                    serviceProvider: '0xProvider1',
                    payee: '0xProvider1',
                    name: 'Provider 1',
                    description: 'Test provider',
                    active: true,
                    products: {
                        PDP: {
                            type: 'PDP',
                            isActive: true,
                            capabilities: {},
                            data: {
                                serviceURL: 'https://pdp1.example.com',
                                minPieceSizeInBytes: BigInt(1024),
                                maxPieceSizeInBytes: BigInt(32) * BigInt(1024) * BigInt(1024) * BigInt(1024),
                                ipniPiece: false,
                                ipniIpfs: false,
                                storagePricePerTibPerMonth: BigInt(1000000),
                                minProvingPeriodInEpochs: 30,
                                location: 'us-east',
                                paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                            },
                        },
                    },
                },
                {
                    id: 2,
                    serviceProvider: '0xProvider2',
                    payee: '0xProvider2',
                    name: 'Provider 2',
                    description: 'Test provider',
                    active: true,
                    products: {
                        PDP: {
                            type: 'PDP',
                            isActive: true,
                            capabilities: {},
                            data: {
                                serviceURL: 'https://pdp2.example.com',
                                minPieceSizeInBytes: BigInt(1024),
                                maxPieceSizeInBytes: BigInt(32) * BigInt(1024) * BigInt(1024) * BigInt(1024),
                                ipniPiece: false,
                                ipniIpfs: false,
                                storagePricePerTibPerMonth: BigInt(1000000),
                                minProvingPeriodInEpochs: 30,
                                location: 'us-east',
                                paymentTokenAddress: '0x0000000000000000000000000000000000000000',
                            },
                        },
                    },
                },
            ];
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => dataSets,
                getProvider: () => null,
                isProviderIdApproved: async (providerId) => providerId === 1 || providerId === 2,
                getApprovedProviderIds: async () => [1, 2],
                getViewContractAddress: () => '0xViewContract',
            };
            const mockSPRegistry = {
                getProviders: async (ids) => {
                    return ids.map((id) => providers.find((p) => p.id === id)).filter((p) => p != null);
                },
            };
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('pdp1.example.com')) {
                    return new Response(null, { status: 404 });
                }
                if (url.includes('pdp2.example.com')) {
                    await new Promise((resolve) => setTimeout(resolve, 50));
                    if (url.includes('/piece/')) {
                        return new Response('success from provider 2', { status: 200 });
                    }
                    return new Response(null, { status: 200 });
                }
                throw new Error(`Unexpected URL: ${url}`);
            };
            try {
                const response = await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.equal(response.status, 200);
                assert.equal(await response.text(), 'success from provider 2');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should race multiple providers and return first success', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [
                    mockDataSet,
                    { ...mockDataSet, providerId: 2, payee: mockProvider2.serviceProvider },
                ],
                getProvider: () => null,
                isProviderIdApproved: async (providerId) => providerId === 1 || providerId === 2,
                getApprovedProviderIds: async () => [1, 2],
                getViewContractAddress: () => '0xViewContract',
            };
            const mockSPRegistry = {
                getProviders: async (ids) => {
                    return ids
                        .map((id) => {
                        if (id === 1)
                            return mockProvider1;
                        if (id === 2)
                            return mockProvider2;
                        return null;
                    })
                        .filter((p) => p != null);
                },
            };
            const originalFetch = global.fetch;
            let provider1Called = false;
            let provider2Called = false;
            global.fetch = async (input, _init) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('provider1.example.com')) {
                    provider1Called = true;
                    if (url.includes('/piece/')) {
                        await new Promise((resolve) => setTimeout(resolve, 100));
                        return new Response('data from provider1', { status: 200 });
                    }
                    return new Response('', { status: 200 });
                }
                if (url.includes('provider2.example.com')) {
                    provider2Called = true;
                    if (url.includes('/piece/')) {
                        await new Promise((resolve) => setTimeout(resolve, 10));
                        return new Response('data from provider2', { status: 200 });
                    }
                    return new Response('', { status: 200 });
                }
                throw new Error('Unexpected URL');
            };
            try {
                const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
                const response = await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.isTrue(provider1Called || provider2Called, 'At least one provider should be called');
                assert.equal(response.status, 200);
                const text = await response.text();
                assert.include(['data from provider1', 'data from provider2'], text);
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should fall back to child retriever when all providers fail', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [mockDataSet],
                getProvider: () => null,
            };
            const mockSPRegistry = {
                getProviders: async () => [mockProvider1],
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return new Response('Not found', { status: 404 });
            };
            try {
                const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry, mockChildRetriever);
                const response = await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.equal(response.status, 200);
                assert.equal(await response.text(), 'data from child');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should throw when all providers fail and no child retriever', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [mockDataSet],
                getProvider: () => null,
                isProviderIdApproved: async () => true,
                getApprovedProviderIds: async () => [1],
                getViewContractAddress: () => '0xViewContract',
            };
            const mockSPRegistry = {
                getProviders: async () => [mockProvider1],
            };
            const originalFetch = global.fetch;
            global.fetch = async () => {
                return new Response('Not found', { status: 404 });
            };
            try {
                const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
                await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'All provider retrieval attempts failed');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle child retriever when no data sets exist', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [],
                getProvider: () => null,
            };
            const mockSPRegistry = {};
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry, mockChildRetriever);
            const response = await retriever.fetchPiece(mockPieceCID, '0xClient');
            assert.equal(response.status, 200);
            assert.equal(await response.text(), 'data from child');
        });
        it('should throw when no data sets and no child retriever', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [],
                getProvider: () => null,
            };
            const mockSPRegistry = {};
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
            try {
                await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'No active data sets with data found');
            }
        });
    });
    describe('fetchPiece error handling', () => {
        it('should throw error when provider discovery fails', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => {
                    throw new Error('Database connection failed');
                },
                getProvider: () => null,
            };
            const mockSPRegistry = {};
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
            try {
                await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'Database connection failed');
            }
        });
        it('should handle provider with no PDP product', async () => {
            const providerNoPDP = {
                ...mockProvider1,
                products: {},
            };
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [mockDataSet],
                getProvider: () => null,
                isProviderIdApproved: async () => true,
                getApprovedProviderIds: async () => [1],
                getViewContractAddress: () => '0xViewContract',
            };
            const mockSPRegistry = {
                getProviders: async () => [providerNoPDP],
            };
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
            try {
                await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'All provider retrieval attempts failed');
            }
        });
        it('should handle mixed success and failure from multiple providers', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [
                    mockDataSet,
                    { ...mockDataSet, providerId: 2, payee: mockProvider2.serviceProvider },
                ],
                getProvider: () => null,
                isProviderIdApproved: async (providerId) => providerId === 1 || providerId === 2,
                getApprovedProviderIds: async () => [1, 2],
                getViewContractAddress: () => '0xViewContract',
            };
            const mockSPRegistry = {
                getProviders: async () => [mockProvider1, mockProvider2],
            };
            const originalFetch = global.fetch;
            global.fetch = async (input) => {
                const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
                if (url.includes('provider1.example.com')) {
                    return new Response('Server error', { status: 500 });
                }
                if (url.includes('provider2.example.com')) {
                    if (url.includes('/piece/')) {
                        return new Response('success from provider2', { status: 200 });
                    }
                    return new Response('', { status: 200 });
                }
                throw new Error('Unexpected URL');
            };
            try {
                const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
                const response = await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.equal(response.status, 200);
                assert.equal(await response.text(), 'success from provider2');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
        it('should handle providers with no valid data sets', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [
                    { ...mockDataSet, isLive: false },
                    { ...mockDataSet, currentPieceCount: 0 },
                ],
                getProvider: () => null,
            };
            const mockSPRegistry = {};
            const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
            try {
                await retriever.fetchPiece(mockPieceCID, '0xClient');
                assert.fail('Should have thrown');
            }
            catch (error) {
                assert.include(error.message, 'No active data sets with data found');
            }
        });
    });
    describe('AbortSignal support', () => {
        it('should pass AbortSignal to provider fetch', async () => {
            const mockWarmStorage = {
                getClientDataSetsWithDetails: async () => [mockDataSet],
                getProvider: () => null,
                isProviderIdApproved: async () => true,
                getApprovedProviderIds: async () => [1],
                getViewContractAddress: () => '0xViewContract',
            };
            const mockSPRegistry = {
                getProviders: async () => [mockProvider1],
            };
            const originalFetch = global.fetch;
            let signalPassed = false;
            global.fetch = async (_input, init) => {
                if (init?.signal) {
                    signalPassed = true;
                }
                return new Response('test data', { status: 200 });
            };
            try {
                const controller = new AbortController();
                const retriever = new ChainRetriever(mockWarmStorage, mockSPRegistry);
                await retriever.fetchPiece(mockPieceCID, '0xClient', { signal: controller.signal });
                assert.isTrue(signalPassed, 'AbortSignal should be passed to fetch');
            }
            finally {
                global.fetch = originalFetch;
            }
        });
    });
});
//# sourceMappingURL=retriever-chain.test.js.map