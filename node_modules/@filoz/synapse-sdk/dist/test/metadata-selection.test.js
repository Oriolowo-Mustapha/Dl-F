import { assert } from 'chai';
import { ethers } from 'ethers';
import { setup } from 'iso-web/msw';
import { METADATA_KEYS } from "../utils/constants.js";
import { metadataMatches, withCDNToMetadata } from "../utils/metadata.js";
import { WarmStorageService } from "../warm-storage/index.js";
import { ADDRESSES, JSONRPC, presets } from "./mocks/jsonrpc/index.js";
describe('Metadata-based Data Set Selection', () => {
    describe('Metadata Utilities', () => {
        describe('metadataMatches', () => {
            it('should not match when data set has extra keys', () => {
                const dataSetMetadata = {
                    environment: 'production',
                    [METADATA_KEYS.WITH_CDN]: '',
                    region: 'us-east',
                };
                const requested = {
                    [METADATA_KEYS.WITH_CDN]: '',
                    environment: 'production',
                };
                assert.isFalse(metadataMatches(dataSetMetadata, requested));
            });
            it('should not match when requested value differs', () => {
                const dataSetMetadata = {
                    environment: 'production',
                    [METADATA_KEYS.WITH_CDN]: '',
                };
                const requested = { environment: 'development' };
                assert.isFalse(metadataMatches(dataSetMetadata, requested));
            });
            it('should not match when requested key is missing', () => {
                const dataSetMetadata = { environment: 'production' };
                const requested = { [METADATA_KEYS.WITH_CDN]: '' };
                assert.isFalse(metadataMatches(dataSetMetadata, requested));
            });
            it('should not match when data set has metadata but empty requested', () => {
                const dataSetMetadata = { environment: 'production' };
                const requested = {};
                assert.isFalse(metadataMatches(dataSetMetadata, requested));
            });
            it('should be order-independent with exact matching', () => {
                const dataSetMetadata = {
                    b: '2',
                    a: '1',
                    c: '3',
                };
                const requested = {
                    c: '3',
                    a: '1',
                    b: '2',
                };
                assert.isTrue(metadataMatches(dataSetMetadata, requested));
            });
            it('should match when both have empty metadata', () => {
                const dataSetMetadata = {};
                const requested = {};
                assert.isTrue(metadataMatches(dataSetMetadata, requested));
            });
            it('should match when metadata is exactly the same', () => {
                const dataSetMetadata = {
                    [METADATA_KEYS.WITH_CDN]: '',
                    environment: 'production',
                };
                const requested = {
                    [METADATA_KEYS.WITH_CDN]: '',
                    environment: 'production',
                };
                assert.isTrue(metadataMatches(dataSetMetadata, requested));
            });
        });
        describe('withCDNToMetadata', () => {
            it('should convert true to metadata entry', () => {
                const metadata = withCDNToMetadata(true);
                assert.equal(metadata.length, 1);
                assert.equal(metadata[0].key, METADATA_KEYS.WITH_CDN);
                assert.equal(metadata[0].value, '');
            });
            it('should convert false to empty array', () => {
                const metadata = withCDNToMetadata(false);
                assert.equal(metadata.length, 0);
            });
        });
    });
    describe('WarmStorageService with Metadata', () => {
        let server;
        let warmStorageService;
        before(async () => {
            server = setup([]);
            await server.start({ quiet: true });
        });
        after(() => {
            server.stop();
        });
        beforeEach(async () => {
            server.resetHandlers();
            const customPreset = {
                ...presets.basic,
                warmStorageView: {
                    ...presets.basic.warmStorageView,
                    railToDataSet: (args) => {
                        const [railId] = args;
                        return [railId];
                    },
                    getClientDataSets: () => [
                        [
                            {
                                pdpRailId: 1n,
                                cacheMissRailId: 0n,
                                cdnRailId: 0n,
                                payer: ADDRESSES.client1,
                                payee: ADDRESSES.serviceProvider1,
                                serviceProvider: ADDRESSES.serviceProvider1,
                                commissionBps: 100n,
                                clientDataSetId: 0n,
                                pdpEndEpoch: 0n,
                                providerId: 1n,
                                cdnEndEpoch: 0n,
                            },
                            {
                                pdpRailId: 2n,
                                cacheMissRailId: 0n,
                                cdnRailId: 100n,
                                payer: ADDRESSES.client1,
                                payee: ADDRESSES.serviceProvider1,
                                serviceProvider: ADDRESSES.serviceProvider1,
                                commissionBps: 100n,
                                clientDataSetId: 1n,
                                pdpEndEpoch: 0n,
                                providerId: 1n,
                                cdnEndEpoch: 0n,
                            },
                            {
                                pdpRailId: 3n,
                                cacheMissRailId: 0n,
                                cdnRailId: 0n,
                                payer: ADDRESSES.client1,
                                payee: ADDRESSES.serviceProvider2,
                                serviceProvider: ADDRESSES.serviceProvider2,
                                commissionBps: 100n,
                                clientDataSetId: 2n,
                                pdpEndEpoch: 0n,
                                providerId: 2n,
                                cdnEndEpoch: 0n,
                            },
                        ],
                    ],
                    getAllDataSetMetadata: (args) => {
                        const [dataSetId] = args;
                        if (dataSetId === 1n) {
                            return [[], []];
                        }
                        if (dataSetId === 2n) {
                            return [[METADATA_KEYS.WITH_CDN], ['']];
                        }
                        if (dataSetId === 3n) {
                            return [[METADATA_KEYS.WITH_IPFS_INDEXING], ['']];
                        }
                        return [[], []];
                    },
                },
                pdpVerifier: {
                    ...presets.basic.pdpVerifier,
                    getNextPieceId: (args) => {
                        const [dataSetId] = args;
                        if (dataSetId === 1n)
                            return [5n];
                        if (dataSetId === 2n)
                            return [0n];
                        if (dataSetId === 3n)
                            return [2n];
                        return [0n];
                    },
                },
            };
            server.use(JSONRPC(customPreset));
            const provider = new ethers.JsonRpcProvider('https://api.calibration.node.glif.io/rpc/v1');
            warmStorageService = await WarmStorageService.create(provider, ADDRESSES.calibration.warmStorage);
        });
        it('should fetch metadata for each data set', async () => {
            const dataSets = await warmStorageService.getClientDataSetsWithDetails(ADDRESSES.client1);
            assert.equal(dataSets.length, 3);
            assert.equal(dataSets[0].pdpVerifierDataSetId, 1);
            assert.isFalse(dataSets[0].withCDN);
            assert.deepEqual(dataSets[0].metadata, {});
            assert.equal(dataSets[1].pdpVerifierDataSetId, 2);
            assert.isTrue(dataSets[1].withCDN);
            assert.deepEqual(dataSets[1].metadata, { [METADATA_KEYS.WITH_CDN]: '' });
            assert.equal(dataSets[2].pdpVerifierDataSetId, 3);
            assert.isFalse(dataSets[2].withCDN);
            assert.deepEqual(dataSets[2].metadata, { [METADATA_KEYS.WITH_IPFS_INDEXING]: '' });
        });
        it('should prefer data sets with matching metadata', async () => {
            const dataSets = await warmStorageService.getClientDataSetsWithDetails(ADDRESSES.client1);
            const withIndexing = dataSets.filter((ds) => metadataMatches(ds.metadata, { [METADATA_KEYS.WITH_IPFS_INDEXING]: '' }));
            assert.equal(withIndexing.length, 1);
            assert.equal(withIndexing[0].pdpVerifierDataSetId, 3);
            const withCDN = dataSets.filter((ds) => metadataMatches(ds.metadata, { [METADATA_KEYS.WITH_CDN]: '' }));
            assert.equal(withCDN.length, 1);
            assert.equal(withCDN[0].pdpVerifierDataSetId, 2);
            const noRequirements = dataSets.filter((ds) => metadataMatches(ds.metadata, {}));
            assert.equal(noRequirements.length, 1);
            assert.equal(noRequirements[0].pdpVerifierDataSetId, 1);
        });
    });
});
//# sourceMappingURL=metadata-selection.test.js.map