import { createError } from "../utils/index.js";
import { ProviderResolver } from "../utils/provider-resolver.js";
import { fetchPiecesFromProviders } from "./utils.js";
export class ChainRetriever {
    warmStorageService;
    childRetriever;
    spRegistry;
    constructor(warmStorageService, spRegistry, childRetriever) {
        this.warmStorageService = warmStorageService;
        this.spRegistry = spRegistry;
        this.childRetriever = childRetriever;
    }
    async findProviders(client, providerAddress) {
        const resolver = new ProviderResolver(this.warmStorageService, this.spRegistry);
        if (providerAddress != null) {
            const provider = await resolver.getApprovedProviderByAddress(providerAddress);
            if (provider == null) {
                throw createError('ChainRetriever', 'findProviders', `Provider ${providerAddress} not found or not approved`);
            }
            return [provider];
        }
        const dataSets = await this.warmStorageService.getClientDataSetsWithDetails(client);
        const validDataSets = dataSets.filter((ds) => ds.isLive && ds.currentPieceCount > 0);
        if (validDataSets.length === 0) {
            throw createError('ChainRetriever', 'findProviders', `No active data sets with data found for client ${client}`);
        }
        const uniqueProviderIds = [...new Set(validDataSets.map((ds) => ds.providerId))];
        const providerInfos = await resolver.getApprovedProvidersByIds(uniqueProviderIds);
        const validProviderInfos = providerInfos.filter((info) => info != null);
        if (validProviderInfos.length === 0) {
            throw createError('ChainRetriever', 'findProviders', 'No valid providers found (all providers may have been removed or are inactive)');
        }
        return validProviderInfos;
    }
    async fetchPiece(pieceCid, client, options) {
        const tryChildOrThrow = async (reason) => {
            if (this.childRetriever !== undefined) {
                return await this.childRetriever.fetchPiece(pieceCid, client, options);
            }
            throw createError('ChainRetriever', 'fetchPiece', `Failed to retrieve piece ${pieceCid.toString()}: ${reason}`);
        };
        let providersToTry = [];
        try {
            providersToTry = await this.findProviders(client, options?.providerAddress);
        }
        catch (error) {
            const message = error instanceof Error ? error.message : 'Provider discovery failed';
            return await tryChildOrThrow(message);
        }
        if (providersToTry.length === 0) {
            return await tryChildOrThrow('No providers found and no additional retriever method was configured');
        }
        try {
            return await fetchPiecesFromProviders(providersToTry, pieceCid, 'ChainRetriever', options?.signal);
        }
        catch {
            return await tryChildOrThrow('All provider retrieval attempts failed and no additional retriever method was configured');
        }
    }
}
//# sourceMappingURL=chain.js.map