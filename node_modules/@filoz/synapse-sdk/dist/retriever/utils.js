import { createError } from "../utils/errors.js";
import { constructFindPieceUrl, constructPieceUrl } from "../utils/piece.js";
export async function fetchPiecesFromProviders(providers, pieceCid, retrieverName, signal) {
    const failures = [];
    const abortControllers = [];
    const providerAttempts = providers.map(async (provider, index) => {
        const controller = new AbortController();
        abortControllers[index] = controller;
        if (signal != null) {
            signal.addEventListener('abort', () => {
                controller.abort(signal.reason);
            }, { once: true });
            if (signal.aborted) {
                controller.abort(signal.reason);
            }
        }
        try {
            if (!provider.products.PDP?.data.serviceURL) {
                throw new Error(`Provider ${provider.id} does not have PDP product with serviceURL`);
            }
            const findUrl = constructFindPieceUrl(provider.products.PDP.data.serviceURL, pieceCid);
            const findResponse = await fetch(findUrl, {
                signal: controller.signal,
            });
            if (!findResponse.ok) {
                failures.push({
                    provider: provider.serviceProvider,
                    error: `findPiece returned ${findResponse.status}`,
                });
                throw new Error('Provider does not have piece');
            }
            const downloadUrl = constructPieceUrl(provider.products.PDP.data.serviceURL, pieceCid);
            const response = await fetch(downloadUrl, {
                signal: controller.signal,
            });
            if (response.ok) {
                return { response, index };
            }
            failures.push({
                provider: provider.serviceProvider,
                error: `download returned ${response.status}`,
            });
            throw new Error(`Download failed with status ${response.status}`);
        }
        catch (error) {
            const errorMsg = error.message ?? 'Unknown error';
            if (!failures.some((f) => f.provider === provider.serviceProvider)) {
                failures.push({ provider: provider.serviceProvider, error: errorMsg });
            }
            console.warn(`Failed to fetch from provider ${provider.serviceProvider}:`, errorMsg);
            throw error;
        }
    });
    try {
        const { response, index: winnerIndex } = await Promise.any(providerAttempts);
        abortControllers.forEach((ctrl, i) => {
            if (i !== winnerIndex) {
                ctrl.abort();
            }
        });
        return response;
    }
    catch (error) {
        if (error instanceof AggregateError) {
            const failureDetails = failures.map((f) => `${f.provider}: ${f.error}`).join('; ');
            throw createError(retrieverName, 'fetchPiecesFromProviders', `All providers failed to serve piece ${pieceCid.toString()}. Details: ${failureDetails}`);
        }
        throw error;
    }
}
//# sourceMappingURL=utils.js.map